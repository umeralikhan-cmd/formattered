{
  "version": 3,
  "sources": ["../../vuetify/src/components/VProgressLinear/VProgressLinear.tsx", "../../vuetify/src/components/VProgressLinear/chunks.ts"],
  "sourcesContent": ["// Styles\nimport './VProgressLinear.sass'\n\n// Composables\nimport { useBackgroundColor, useTextColor } from '@/composables/color'\nimport { makeComponentProps } from '@/composables/component'\nimport { useIntersectionObserver } from '@/composables/intersectionObserver'\nimport { useRtl } from '@/composables/locale'\nimport { makeLocationProps, useLocation } from '@/composables/location'\nimport { useProxiedModel } from '@/composables/proxiedModel'\nimport { useResizeObserver } from '@/composables/resizeObserver'\nimport { makeRoundedProps, useRounded } from '@/composables/rounded'\nimport { makeTagProps } from '@/composables/tag'\nimport { makeThemeProps, provideTheme } from '@/composables/theme'\nimport { useToggleScope } from '@/composables/toggleScope'\n\n// Utilities\nimport { computed, ref, shallowRef, Transition, watchEffect } from 'vue'\nimport { makeChunksProps, useChunks } from './chunks'\nimport { clamp, convertToUnit, genericComponent, propsFactory, useRender } from '@/util'\n\ntype VProgressLinearSlots = {\n  default: { value: number, buffer: number }\n}\n\nexport const makeVProgressLinearProps = propsFactory({\n  absolute: Boolean,\n  active: {\n    type: Boolean,\n    default: true,\n  },\n  bgColor: String,\n  bgOpacity: [Number, String],\n  bufferValue: {\n    type: [Number, String],\n    default: 0,\n  },\n  bufferColor: String,\n  bufferOpacity: [Number, String],\n  clickable: Boolean,\n  color: String,\n  height: {\n    type: [Number, String],\n    default: 4,\n  },\n  indeterminate: Boolean,\n  max: {\n    type: [Number, String],\n    default: 100,\n  },\n  modelValue: {\n    type: [Number, String],\n    default: 0,\n  },\n  opacity: [Number, String],\n  reverse: Boolean,\n  stream: Boolean,\n  striped: Boolean,\n  roundedBar: Boolean,\n\n  ...makeChunksProps(),\n  ...makeComponentProps(),\n  ...makeLocationProps({ location: 'top' } as const),\n  ...makeRoundedProps(),\n  ...makeTagProps(),\n  ...makeThemeProps(),\n}, 'VProgressLinear')\n\nexport const VProgressLinear = genericComponent<VProgressLinearSlots>()({\n  name: 'VProgressLinear',\n\n  props: makeVProgressLinearProps(),\n\n  emits: {\n    'update:modelValue': (value: number) => true,\n  },\n\n  setup (props, { slots }) {\n    const root = ref<HTMLElement>()\n\n    const progress = useProxiedModel(props, 'modelValue')\n    const { isRtl, rtlClasses } = useRtl()\n    const { themeClasses } = provideTheme(props)\n    const { locationStyles } = useLocation(props)\n    const { textColorClasses, textColorStyles } = useTextColor(() => props.color)\n    const {\n      backgroundColorClasses,\n      backgroundColorStyles,\n    } = useBackgroundColor(() => props.bgColor || props.color)\n    const {\n      backgroundColorClasses: bufferColorClasses,\n      backgroundColorStyles: bufferColorStyles,\n    } = useBackgroundColor(() => props.bufferColor || props.bgColor || props.color)\n    const {\n      backgroundColorClasses: barColorClasses,\n      backgroundColorStyles: barColorStyles,\n    } = useBackgroundColor(() => props.color)\n    const { roundedClasses } = useRounded(props)\n    const { intersectionRef, isIntersecting } = useIntersectionObserver()\n\n    const max = computed(() => parseFloat(props.max))\n    const height = computed(() => parseFloat(props.height))\n    const normalizedBuffer = computed(() => clamp(parseFloat(props.bufferValue) / max.value * 100, 0, 100))\n    const normalizedValue = computed(() => clamp(parseFloat(progress.value) / max.value * 100, 0, 100))\n    const isReversed = computed(() => isRtl.value !== props.reverse)\n    const transition = computed(() => props.indeterminate ? 'fade-transition' : 'slide-x-transition')\n\n    const containerWidth = shallowRef(0)\n    const { hasChunks, chunksMaskStyles, snapValueToChunk } = useChunks(props, containerWidth)\n    useToggleScope(hasChunks, () => {\n      const { resizeRef } = useResizeObserver(entries => containerWidth.value = entries[0].contentRect.width)\n      watchEffect(() => resizeRef.value = root.value)\n    })\n\n    const bufferWidth = computed(() => {\n      return hasChunks.value\n        ? snapValueToChunk(normalizedBuffer.value)\n        : normalizedBuffer.value\n    })\n\n    const barWidth = computed(() => {\n      return hasChunks.value\n        ? snapValueToChunk(normalizedValue.value)\n        : normalizedValue.value\n    })\n\n    function handleClick (e: MouseEvent) {\n      if (!intersectionRef.value) return\n\n      const { left, right, width } = intersectionRef.value.getBoundingClientRect()\n      const value = isReversed.value ? (width - e.clientX) + (right - width) : e.clientX - left\n\n      progress.value = Math.round(value / width * max.value)\n    }\n\n    watchEffect(() => {\n      intersectionRef.value = root.value\n    })\n\n    useRender(() => (\n      <props.tag\n        ref={ root }\n        class={[\n          'v-progress-linear',\n          {\n            'v-progress-linear--absolute': props.absolute,\n            'v-progress-linear--active': props.active && isIntersecting.value,\n            'v-progress-linear--reverse': isReversed.value,\n            'v-progress-linear--rounded': props.rounded,\n            'v-progress-linear--rounded-bar': props.roundedBar,\n            'v-progress-linear--striped': props.striped,\n            'v-progress-linear--clickable': props.clickable,\n          },\n          roundedClasses.value,\n          themeClasses.value,\n          rtlClasses.value,\n          props.class,\n        ]}\n        style={[\n          {\n            bottom: props.location === 'bottom' ? 0 : undefined,\n            top: props.location === 'top' ? 0 : undefined,\n            height: props.active ? convertToUnit(height.value) : 0,\n            '--v-progress-linear-height': convertToUnit(height.value),\n            ...(props.absolute ? locationStyles.value : {}),\n          },\n          chunksMaskStyles.value,\n          props.style,\n        ]}\n        role=\"progressbar\"\n        aria-hidden={ props.active ? 'false' : 'true' }\n        aria-valuemin=\"0\"\n        aria-valuemax={ props.max }\n        aria-valuenow={ props.indeterminate ? undefined : Math.min(parseFloat(progress.value), max.value) }\n        onClick={ props.clickable && handleClick }\n      >\n        { props.stream && (\n          <div\n            key=\"stream\"\n            class={[\n              'v-progress-linear__stream',\n              textColorClasses.value,\n            ]}\n            style={{\n              ...textColorStyles.value,\n              [isReversed.value ? 'left' : 'right']: convertToUnit(-height.value),\n              borderTop: `${convertToUnit(height.value / 2)} dotted`,\n              opacity: parseFloat(props.bufferOpacity!),\n              top: `calc(50% - ${convertToUnit(height.value / 4)})`,\n              width: convertToUnit(100 - normalizedBuffer.value, '%'),\n              '--v-progress-linear-stream-to': convertToUnit(height.value * (isReversed.value ? 1 : -1)),\n            }}\n          />\n        )}\n\n        <div\n          class={[\n            'v-progress-linear__background',\n            backgroundColorClasses.value,\n          ]}\n          style={[\n            backgroundColorStyles.value,\n            {\n              opacity: parseFloat(props.bgOpacity!),\n              width: props.stream ? 0 : undefined,\n            },\n          ]}\n        />\n\n        <div\n          class={[\n            'v-progress-linear__buffer',\n            bufferColorClasses.value,\n          ]}\n          style={[\n            bufferColorStyles.value,\n            {\n              opacity: parseFloat(props.bufferOpacity!),\n              width: convertToUnit(bufferWidth.value, '%'),\n            },\n          ]}\n        />\n\n        <Transition name={ transition.value }>\n          { !props.indeterminate ? (\n            <div\n              class={[\n                'v-progress-linear__determinate',\n                barColorClasses.value,\n              ]}\n              style={[\n                barColorStyles.value,\n                { width: convertToUnit(barWidth.value, '%') },\n              ]}\n            />\n          ) : (\n            <div class=\"v-progress-linear__indeterminate\">\n              {['long', 'short'].map(bar => (\n                <div\n                  key={ bar }\n                  class={[\n                    'v-progress-linear__indeterminate',\n                    bar,\n                    barColorClasses.value,\n                  ]}\n                  style={ barColorStyles.value }\n                />\n              ))}\n            </div>\n          )}\n        </Transition>\n\n        { slots.default && (\n          <div class=\"v-progress-linear__content\">\n            { slots.default({ value: normalizedValue.value, buffer: normalizedBuffer.value }) }\n          </div>\n        )}\n      </props.tag>\n    ))\n\n    return {}\n  },\n})\n\nexport type VProgressLinear = InstanceType<typeof VProgressLinear>\n", "// Utilities\nimport { computed, toRef, toValue } from 'vue'\nimport { clamp, convertToUnit, propsFactory } from '@/util'\n\n// Types\nimport type { MaybeRefOrGetter } from 'vue'\n\nexport interface ChunksProps {\n  chunkCount: number | string\n  chunkWidth: number | string\n  chunkGap: number | string\n}\n\n// Composables\nexport const makeChunksProps = propsFactory({\n  chunkCount: {\n    type: [Number, String],\n    default: null,\n  },\n  chunkWidth: {\n    type: [Number, String],\n    default: null,\n  },\n  chunkGap: {\n    type: [Number, String],\n    default: 4,\n  },\n}, 'chunks')\n\nexport function useChunks (\n  props: ChunksProps,\n  containerWidth: MaybeRefOrGetter<number | undefined>,\n) {\n  const hasChunks = toRef(() => !!props.chunkCount || !!props.chunkWidth)\n\n  const chunkWidth = computed(() => {\n    const containerSize = toValue(containerWidth)\n    if (!containerSize) {\n      return 0\n    }\n\n    if (!props.chunkCount) {\n      return Number(props.chunkWidth)\n    }\n\n    const count = Number(props.chunkCount)\n    const availableWidth = containerSize - Number(props.chunkGap) * (count - 1)\n    return availableWidth / count\n  })\n\n  const chunkGap = toRef(() => Number(props.chunkGap))\n  const chunksMaskStyles = computed(() => {\n    if (!hasChunks.value) {\n      return {}\n    }\n\n    const chunkGapPx = convertToUnit(chunkGap.value)\n    const chunkWidthPx = convertToUnit(chunkWidth.value)\n\n    return {\n      maskRepeat: 'repeat-x',\n      maskImage: `linear-gradient(90deg, #000, #000 ${chunkWidthPx}, transparent ${chunkWidthPx}, transparent)`,\n      maskSize: `calc(${chunkWidthPx} + ${chunkGapPx}) 100%`,\n    }\n  })\n\n  function snapValueToChunk (val: number) {\n    const containerSize = toValue(containerWidth)\n    if (!containerSize) {\n      return val\n    }\n\n    const gapRelativeSize = 100 * chunkGap.value / containerSize\n    const chunkRelativeSize = 100 * (chunkWidth.value + chunkGap.value) / containerSize\n    const filledChunks = Math.floor((val + gapRelativeSize) / chunkRelativeSize)\n    return clamp(0, filledChunks * chunkRelativeSize - gapRelativeSize / 2, 100)\n  }\n\n  return {\n    hasChunks,\n    chunksMaskStyles,\n    snapValueToChunk,\n  }\n}\n"],
  "mappings": "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",
  "names": ["makeChunksProps", "propsFactory", "chunkCount", "type", "Number", "String", "default", "chunkWidth", "chunkGap", "useChunks", "props", "containerWidth", "hasChunks", "toRef", "computed", "containerSize", "toValue", "count", "availableWidth", "chunksMaskStyles", "value", "chunkGapPx", "convertToUnit", "chunkWidthPx", "maskRepeat", "maskImage", "maskSize", "snapValueToChunk", "val", "gapRelativeSize", "chunkRelativeSize", "filledChunks", "Math", "floor", "clamp", "makeVProgressLinearProps", "propsFactory", "absolute", "Boolean", "active", "type", "default", "bgColor", "String", "bgOpacity", "Number", "bufferValue", "bufferColor", "bufferOpacity", "clickable", "color", "height", "indeterminate", "max", "modelValue", "opacity", "reverse", "stream", "striped", "roundedBar", "makeChunksProps", "makeComponentProps", "makeLocationProps", "location", "makeRoundedProps", "makeTagProps", "makeThemeProps", "VProgressLinear", "genericComponent", "name", "props", "emits", "value", "setup", "_ref", "slots", "root", "ref", "progress", "useProxiedModel", "isRtl", "rtlClasses", "useRtl", "themeClasses", "provideTheme", "locationStyles", "useLocation", "textColorClasses", "textColorStyles", "useTextColor", "backgroundColorClasses", "backgroundColorStyles", "useBackgroundColor", "bufferColorClasses", "bufferColorStyles", "barColorClasses", "barColorStyles", "roundedClasses", "useRounded", "intersectionRef", "isIntersecting", "useIntersectionObserver", "computed", "parseFloat", "normalizedBuffer", "clamp", "normalizedValue", "isReversed", "transition", "containerWidth", "shallowRef", "hasChunks", "chunksMaskStyles", "snapValueToChunk", "useChunks", "useToggleScope", "resizeRef", "useResizeObserver", "entries", "contentRect", "width", "watchEffect", "bufferWidth", "barWidth", "handleClick", "e", "left", "right", "getBoundingClientRect", "clientX", "Math", "round", "useRender", "_createVNode", "tag", "_normalizeClass", "rounded", "class", "_normalizeStyle", "bottom", "undefined", "top", "convertToUnit", "style", "min", "_createElementVNode", "borderTop", "Transition", "map", "bar", "buffer"]
}
