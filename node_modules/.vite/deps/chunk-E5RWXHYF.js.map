{
  "version": 3,
  "sources": ["../../vuetify/src/composables/filter.tsx"],
  "sourcesContent": ["/* eslint-disable max-statements */\n/* eslint-disable no-labels */\n\n// Utilities\nimport { computed, shallowRef, unref, watchEffect } from 'vue'\nimport { getPropertyFromItem, propsFactory, wrapInArray } from '@/util'\n\n// Types\nimport type { PropType, Ref } from 'vue'\nimport type { MaybeRef } from '@/util'\n\n/**\n * - boolean: match without highlight\n * - number: single match (index), length already known\n * - []: single match (start, end)\n * - [][]: multiple matches (start, end), shouldn't overlap\n */\nexport type FilterMatchArraySingle = readonly [number, number]\nexport type FilterMatchArrayMultiple = readonly FilterMatchArraySingle[]\nexport type FilterMatchArray = FilterMatchArraySingle | FilterMatchArrayMultiple\nexport type FilterMatch = boolean | number | FilterMatchArray\nexport type FilterFunction = (value: string, query: string, item?: InternalItem) => FilterMatch\nexport type FilterKeyFunctions = Record<string, FilterFunction>\nexport type FilterKeys = string | string[]\nexport type FilterMode = 'some' | 'every' | 'union' | 'intersection'\n\nexport interface FilterProps {\n  customFilter?: FilterFunction\n  customKeyFilter?: FilterKeyFunctions\n  filterKeys?: FilterKeys\n  filterMode?: FilterMode\n  noFilter?: boolean\n}\n\nexport interface InternalItem<T = any> {\n  value: any\n  raw: T\n  type?: string\n}\n\ntype FilterResult = {\n  index: number\n  matches: Record<string, FilterMatchArrayMultiple | undefined>\n  type?: 'divider' | 'subheader'\n}\n\n// Composables\nexport const defaultFilter: FilterFunction = (value, query, item) => {\n  if (value == null || query == null) return -1\n  if (!query.length) return 0\n\n  value = value.toString().toLocaleLowerCase()\n  query = query.toString().toLocaleLowerCase()\n\n  const result = []\n  let idx = value.indexOf(query)\n  while (~idx) {\n    result.push([idx, idx + query.length] as const)\n\n    idx = value.indexOf(query, idx + query.length)\n  }\n\n  return result.length ? result : -1\n}\n\nfunction normaliseMatch (match: FilterMatch, query: string): FilterMatchArrayMultiple | undefined {\n  if (match == null || typeof match === 'boolean' || match === -1) return\n  if (typeof match === 'number') return [[match, match + query.length]]\n  if (Array.isArray(match[0])) return match as FilterMatchArrayMultiple\n  return [match] as FilterMatchArrayMultiple\n}\n\nexport const makeFilterProps = propsFactory({\n  customFilter: Function as PropType<FilterFunction>,\n  customKeyFilter: Object as PropType<FilterKeyFunctions>,\n  filterKeys: [Array, String] as PropType<FilterKeys>,\n  filterMode: {\n    type: String as PropType<FilterMode>,\n    default: 'intersection',\n  },\n  noFilter: Boolean,\n}, 'filter')\n\n// eslint-disable-next-line complexity\nexport function filterItems (\n  items: readonly (readonly [item: InternalItem, transformed: {}])[] | readonly InternalItem[],\n  query: string,\n  options?: {\n    customKeyFilter?: FilterKeyFunctions\n    default?: FilterFunction\n    filterKeys?: FilterKeys\n    filterMode?: FilterMode\n    noFilter?: boolean\n  },\n) {\n  const array: FilterResult[] = []\n  // always ensure we fall back to a functioning filter\n  const filter = options?.default ?? defaultFilter\n  const keys = options?.filterKeys ? wrapInArray(options.filterKeys) : false\n  const customFiltersLength = Object.keys(options?.customKeyFilter ?? {}).length\n\n  if (!items?.length) return array\n\n  let lookAheadItem: FilterResult | null = null\n\n  loop:\n  for (let i = 0; i < items.length; i++) {\n    const [item, transformed = item] = wrapInArray(items[i]) as readonly [InternalItem, {}]\n    const customMatches: Record<string, FilterMatchArrayMultiple | undefined> = {}\n    const defaultMatches: Record<string, FilterMatchArrayMultiple | undefined> = {}\n    let match: FilterMatch = -1\n\n    if ((query || customFiltersLength > 0) && !options?.noFilter) {\n      let hasOnlyCustomFilters = false\n\n      if (typeof item === 'object') {\n        if (item.type === 'divider' || item.type === 'subheader') {\n          if (lookAheadItem?.type === 'divider' && item.type === 'subheader') {\n            array.push(lookAheadItem) // divider before subheader\n          }\n\n          lookAheadItem = { index: i, matches: { }, type: item.type }\n          continue\n        }\n\n        const filterKeys = keys || Object.keys(transformed)\n        hasOnlyCustomFilters = filterKeys.length === customFiltersLength\n\n        for (const key of filterKeys) {\n          const value = getPropertyFromItem(transformed, key)\n          const keyFilter = options?.customKeyFilter?.[key]\n\n          match = keyFilter\n            ? keyFilter(value, query, item)\n            : filter(value, query, item)\n\n          if (match !== -1 && match !== false) {\n            if (keyFilter) customMatches[key] = normaliseMatch(match, query)\n            else defaultMatches[key] = normaliseMatch(match, query)\n          } else if (options?.filterMode === 'every') {\n            continue loop\n          }\n        }\n      } else {\n        match = filter(item, query, item)\n        if (match !== -1 && match !== false) {\n          defaultMatches.title = normaliseMatch(match, query)\n        }\n      }\n\n      const defaultMatchesLength = Object.keys(defaultMatches).length\n      const customMatchesLength = Object.keys(customMatches).length\n\n      if (!defaultMatchesLength && !customMatchesLength) continue\n\n      if (\n        options?.filterMode === 'union' &&\n        customMatchesLength !== customFiltersLength &&\n        !defaultMatchesLength\n      ) continue\n\n      if (\n        options?.filterMode === 'intersection' &&\n        (\n          customMatchesLength !== customFiltersLength ||\n          (!defaultMatchesLength && customFiltersLength > 0 && !hasOnlyCustomFilters)\n        )\n      ) continue\n    }\n\n    if (lookAheadItem) {\n      array.push(lookAheadItem)\n      lookAheadItem = null\n    }\n\n    array.push({ index: i, matches: { ...defaultMatches, ...customMatches } })\n  }\n\n  return array\n}\n\nexport function useFilter <T extends InternalItem> (\n  props: FilterProps,\n  items: MaybeRef<T[]>,\n  query: Ref<string | undefined> | (() => string | undefined),\n  options?: {\n    transform?: (item: T) => {}\n    customKeyFilter?: MaybeRef<FilterKeyFunctions | undefined>\n  }\n) {\n  const filteredItems = shallowRef<T[]>([])\n  const filteredMatches = shallowRef(new Map<unknown, Record<string, FilterMatchArrayMultiple | undefined>>())\n  const transformedItems = computed(() => (\n    options?.transform\n      ? unref(items).map(item => ([item, options.transform!(item)] as const))\n      : unref(items)\n  ))\n\n  watchEffect(() => {\n    const _query = typeof query === 'function' ? query() : unref(query)\n    const strQuery = (\n      typeof _query !== 'string' &&\n      typeof _query !== 'number'\n    ) ? '' : String(_query)\n\n    const results = filterItems(\n      transformedItems.value,\n      strQuery,\n      {\n        customKeyFilter: {\n          ...props.customKeyFilter,\n          ...unref(options?.customKeyFilter),\n        },\n        default: props.customFilter,\n        filterKeys: props.filterKeys,\n        filterMode: props.filterMode,\n        noFilter: props.noFilter,\n      },\n    )\n\n    const originalItems = unref(items)\n\n    const _filteredItems: typeof filteredItems['value'] = []\n    const _filteredMatches: typeof filteredMatches['value'] = new Map()\n    results.forEach(({ index, matches }) => {\n      const item = originalItems[index]\n      _filteredItems.push(item)\n      _filteredMatches.set(item.value, matches)\n    })\n    filteredItems.value = _filteredItems\n    filteredMatches.value = _filteredMatches\n  })\n\n  function getMatches (item: T) {\n    return filteredMatches.value.get(item.value)\n  }\n\n  return { filteredItems, filteredMatches, getMatches }\n}\n\nexport function highlightResult (name: string, text: string, matches: FilterMatchArrayMultiple | undefined) {\n  if (matches == null || !matches.length) return text\n\n  return matches.map((match, i) => {\n    const start = i === 0 ? 0 : matches[i - 1][1]\n    const result = [\n      <span class={ `${name}__unmask` }>{ text.slice(start, match[0]) }</span>,\n      <span class={ `${name}__mask` }>{ text.slice(match[0], match[1]) }</span>,\n    ]\n    if (i === matches.length - 1) {\n      result.push(<span class={ `${name}__unmask` }>{ text.slice(match[1]) }</span>)\n    }\n    return <>{ result }</>\n  })\n}\n"],
  "mappings": "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",
  "names": ["defaultFilter", "value", "query", "item", "length", "toString", "toLocaleLowerCase", "result", "idx", "indexOf", "push", "normaliseMatch", "match", "Array", "isArray", "makeFilterProps", "propsFactory", "customFilter", "Function", "customKeyFilter", "Object", "filterKeys", "String", "filterMode", "type", "default", "noFilter", "Boolean", "filterItems", "items", "options", "array", "filter", "keys", "wrapInArray", "customFiltersLength", "lookAheadItem", "loop", "i", "transformed", "customMatches", "defaultMatches", "hasOnlyCustomFilters", "index", "matches", "key", "getPropertyFromItem", "keyFilter", "title", "defaultMatchesLength", "customMatchesLength", "useFilter", "props", "filteredItems", "shallowRef", "filteredMatches", "Map", "transformedItems", "computed", "transform", "unref", "map", "watchEffect", "_query", "strQuery", "results", "originalItems", "_filteredItems", "_filteredMatches", "forEach", "_ref", "set", "getMatches", "get", "highlightResult", "name", "text", "start", "_createElementVNode", "_normalizeClass", "slice", "_Fragment"]
}
