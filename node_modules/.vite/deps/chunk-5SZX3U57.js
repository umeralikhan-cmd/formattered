import {
  VSpacer
} from "./chunk-QKIV5OJJ.js";
import {
  VSheet,
  makeVSheetProps
} from "./chunk-RSTJGVPZ.js";
import {
  intersect_default
} from "./chunk-WLOGHTT5.js";
import {
  MaybeTransition,
  makeTransitionProps
} from "./chunk-NIGYBKFM.js";
import {
  VBtn
} from "./chunk-HQFATXNO.js";
import {
  VDefaultsProvider
} from "./chunk-BI2ZIEOH.js";
import {
  makeDimensionProps,
  useDimension
} from "./chunk-NA4HFG2U.js";
import {
  makeLocationProps,
  useLocation
} from "./chunk-XAWYBFQL.js";
import {
  makeRoundedProps,
  useRounded
} from "./chunk-LXYYO6IX.js";
import {
  VIcon
} from "./chunk-7WSZDMNK.js";
import {
  makeTagProps
} from "./chunk-3KA5EREQ.js";
import {
  useBackgroundColor,
  useTextColor
} from "./chunk-EDHH2GNY.js";
import {
  VFadeTransition
} from "./chunk-HTMGZKTH.js";
import {
  createDateRange,
  daysDiff,
  useDate
} from "./chunk-2SG2QLVK.js";
import {
  useLocale,
  useRtl
} from "./chunk-CVODYM32.js";
import {
  useProxiedModel
} from "./chunk-SLGGJV2F.js";
import {
  IconValue
} from "./chunk-YDHPBSMP.js";
import {
  makeThemeProps,
  useTheme
} from "./chunk-XGSXMVDE.js";
import {
  EventProp,
  convertToUnit,
  createRange,
  createSimpleFunctional,
  genericComponent,
  makeComponentProps,
  omit,
  pickWithRest,
  propsFactory,
  templateRef,
  useRender,
  wrapInArray
} from "./chunk-4QS72R7V.js";
import {
  Fragment,
  computed,
  createBaseVNode,
  createTextVNode,
  createVNode,
  mergeProps,
  normalizeClass,
  normalizeStyle,
  ref,
  shallowRef,
  toRef,
  vShow,
  watch,
  watchEffect,
  withDirectives
} from "./chunk-QCNYTOAH.js";

// node_modules/vuetify/lib/components/VDatePicker/VDatePickerControls.js
import "/Users/macbookpro/Documents/CurrentAllWork/bubble1/formattered/node_modules/vuetify/lib/components/VDatePicker/VDatePickerControls.css";
var makeVDatePickerControlsProps = propsFactory({
  active: {
    type: [String, Array],
    default: void 0
  },
  controlHeight: [Number, String],
  controlVariant: {
    type: String,
    default: "docked"
  },
  noMonthPicker: Boolean,
  disabled: {
    type: [Boolean, String, Array],
    default: null
  },
  nextIcon: {
    type: IconValue,
    default: "$next"
  },
  prevIcon: {
    type: IconValue,
    default: "$prev"
  },
  modeIcon: {
    type: IconValue,
    default: "$subgroup"
  },
  text: String,
  monthText: String,
  yearText: String,
  viewMode: {
    type: String,
    default: "month"
  }
}, "VDatePickerControls");
var VDatePickerControls = genericComponent()({
  name: "VDatePickerControls",
  props: makeVDatePickerControlsProps(),
  emits: {
    "click:year": () => true,
    "click:month": () => true,
    "click:prev": () => true,
    "click:next": () => true,
    "click:prev-year": () => true,
    "click:next-year": () => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const disableMonth = computed(() => {
      return Array.isArray(props.disabled) ? props.disabled.includes("text") : !!props.disabled;
    });
    const disableYear = computed(() => {
      return Array.isArray(props.disabled) ? props.disabled.includes("mode") : !!props.disabled;
    });
    const disablePrevMonth = computed(() => {
      return Array.isArray(props.disabled) ? props.disabled.includes("prev-month") : !!props.disabled;
    });
    const disableNextMonth = computed(() => {
      return Array.isArray(props.disabled) ? props.disabled.includes("next-month") : !!props.disabled;
    });
    const disablePrevYear = computed(() => {
      return Array.isArray(props.disabled) ? props.disabled.includes("prev-year") : !!props.disabled;
    });
    const disableNextYear = computed(() => {
      return Array.isArray(props.disabled) ? props.disabled.includes("next-year") : !!props.disabled;
    });
    function onClickPrevMonth() {
      emit("click:prev");
    }
    function onClickNextMonth() {
      emit("click:next");
    }
    function onClickPrevYear() {
      emit("click:prev-year");
    }
    function onClickNextYear() {
      emit("click:next-year");
    }
    function onClickYear() {
      emit("click:year");
    }
    function onClickMonth() {
      emit("click:month");
    }
    useRender(() => {
      const innerDefaults = {
        VBtn: {
          density: "comfortable",
          variant: "text"
        }
      };
      const prevMonth = createVNode(VBtn, {
        "data-testid": "prev-month",
        "disabled": disablePrevMonth.value,
        "icon": props.prevIcon,
        "aria-label": t("$vuetify.datePicker.ariaLabel.previousMonth"),
        "onClick": onClickPrevMonth
      }, null);
      const nextMonth = createVNode(VBtn, {
        "data-testid": "next-month",
        "disabled": disableNextMonth.value,
        "icon": props.nextIcon,
        "aria-label": t("$vuetify.datePicker.ariaLabel.nextMonth"),
        "onClick": onClickNextMonth
      }, null);
      const prevYear = createVNode(VBtn, {
        "data-testid": "prev-year",
        "disabled": disablePrevYear.value,
        "icon": props.prevIcon,
        "aria-label": t("$vuetify.datePicker.ariaLabel.previousYear"),
        "onClick": onClickPrevYear
      }, null);
      const nextYear = createVNode(VBtn, {
        "data-testid": "next-year",
        "disabled": disableNextYear.value,
        "icon": props.nextIcon,
        "aria-label": t("$vuetify.datePicker.ariaLabel.nextYear"),
        "onClick": onClickNextYear
      }, null);
      const onlyMonthBtn = createVNode(VBtn, {
        "class": "v-date-picker-controls__only-month-btn",
        "data-testid": "month-btn",
        "density": "default",
        "disabled": disableMonth.value,
        "text": props.monthText,
        "appendIcon": props.modeIcon,
        "rounded": true,
        "aria-label": t("$vuetify.datePicker.ariaLabel.selectMonth"),
        "onClick": onClickMonth
      }, null);
      const onlyYearBtn = createVNode(VBtn, {
        "class": "v-date-picker-controls__only-year-btn",
        "data-testid": "year-btn",
        "density": "default",
        "disabled": disableYear.value,
        "text": props.yearText,
        "appendIcon": props.modeIcon,
        "rounded": true,
        "aria-label": t("$vuetify.datePicker.ariaLabel.selectYear"),
        "onClick": onClickYear
      }, null);
      const monthYearBtn = createVNode(VBtn, {
        "class": "v-date-picker-controls__year-btn",
        "data-testid": "year-btn",
        "density": "default",
        "disabled": disableYear.value,
        "text": props.text,
        "appendIcon": props.modeIcon,
        "rounded": true,
        "aria-label": t("$vuetify.datePicker.ariaLabel.selectYear"),
        "onClick": onClickYear
      }, null);
      const monthYearSplit = createBaseVNode(Fragment, null, [createVNode(VBtn, {
        "class": "v-date-picker-controls__month-btn",
        "data-testid": "month-btn",
        "height": "36",
        "disabled": disableMonth.value,
        "text": props.text,
        "rounded": true,
        "aria-label": t("$vuetify.datePicker.ariaLabel.selectMonth"),
        "onClick": onClickMonth
      }, null), createVNode(VBtn, {
        "class": "v-date-picker-controls__mode-btn",
        "data-testid": "year-btn",
        "disabled": disableYear.value,
        "icon": props.modeIcon,
        "aria-label": t("$vuetify.datePicker.ariaLabel.selectYear"),
        "onClick": onClickYear
      }, null)]);
      const slotProps = {
        viewMode: props.viewMode,
        disabled: Array.isArray(props.disabled) ? props.disabled : [],
        monthYearText: props.text ?? "",
        monthText: props.monthText ?? "",
        yearText: props.yearText ?? "",
        openMonths: onClickMonth,
        openYears: onClickYear,
        prevMonth: onClickPrevMonth,
        nextMonth: onClickNextMonth,
        prevYear: onClickPrevYear,
        nextYear: onClickNextYear
      };
      const modalControls = createBaseVNode(Fragment, null, [props.noMonthPicker ? monthYearBtn : monthYearSplit, createVNode(VSpacer, null, null), createBaseVNode("div", {
        "class": "v-date-picker-controls__month"
      }, [prevMonth, nextMonth])]);
      const dockedControls = createBaseVNode(Fragment, null, [createBaseVNode("div", {
        "class": "v-date-picker-controls__month"
      }, [prevMonth, onlyMonthBtn, nextMonth]), createVNode(VSpacer, null, null), createBaseVNode("div", {
        "class": "v-date-picker-controls__year"
      }, [prevYear, onlyYearBtn, nextYear])]);
      return createVNode(VDefaultsProvider, {
        "defaults": innerDefaults
      }, {
        default: () => {
          var _a;
          return [createBaseVNode("div", {
            "class": normalizeClass(["v-date-picker-controls", `v-date-picker-controls--variant-${props.controlVariant}`]),
            "style": {
              "--v-date-picker-controls-height": convertToUnit(props.controlHeight)
            }
          }, [((_a = slots.default) == null ? void 0 : _a.call(slots, slotProps)) ?? createBaseVNode(Fragment, null, [props.controlVariant === "modal" && modalControls, props.controlVariant === "docked" && dockedControls])])];
        }
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VDatePicker/VDatePickerHeader.js
import "/Users/macbookpro/Documents/CurrentAllWork/bubble1/formattered/node_modules/vuetify/lib/components/VDatePicker/VDatePickerHeader.css";
var makeVDatePickerHeaderProps = propsFactory({
  appendIcon: IconValue,
  color: String,
  header: String,
  transition: String,
  onClick: EventProp()
}, "VDatePickerHeader");
var VDatePickerHeader = genericComponent()({
  name: "VDatePickerHeader",
  props: makeVDatePickerHeaderProps(),
  emits: {
    click: () => true,
    "click:append": () => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(() => props.color);
    function onClick() {
      emit("click");
    }
    function onClickAppend() {
      emit("click:append");
    }
    useRender(() => {
      const hasContent = !!(slots.default || props.header);
      const hasAppend = !!(slots.append || props.appendIcon);
      return createBaseVNode("div", {
        "class": normalizeClass(["v-date-picker-header", {
          "v-date-picker-header--clickable": !!props.onClick
        }, backgroundColorClasses.value]),
        "style": normalizeStyle(backgroundColorStyles.value),
        "onClick": onClick
      }, [slots.prepend && createBaseVNode("div", {
        "key": "prepend",
        "class": "v-date-picker-header__prepend"
      }, [slots.prepend()]), hasContent && createVNode(MaybeTransition, {
        "key": "content",
        "name": props.transition
      }, {
        default: () => {
          var _a;
          return [createBaseVNode("div", {
            "key": props.header,
            "class": "v-date-picker-header__content"
          }, [((_a = slots.default) == null ? void 0 : _a.call(slots)) ?? props.header])];
        }
      }), hasAppend && createBaseVNode("div", {
        "class": "v-date-picker-header__append"
      }, [!slots.append ? createVNode(VBtn, {
        "key": "append-btn",
        "icon": props.appendIcon,
        "variant": "text",
        "onClick": onClickAppend
      }, null) : createVNode(VDefaultsProvider, {
        "key": "append-defaults",
        "disabled": !props.appendIcon,
        "defaults": {
          VBtn: {
            icon: props.appendIcon,
            variant: "text"
          }
        }
      }, {
        default: () => {
          var _a;
          return [(_a = slots.append) == null ? void 0 : _a.call(slots)];
        }
      })])]);
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VDatePicker/VDatePickerMonth.js
import "/Users/macbookpro/Documents/CurrentAllWork/bubble1/formattered/node_modules/vuetify/lib/components/VDatePicker/VDatePickerMonth.css";

// node_modules/vuetify/lib/components/VBadge/VBadge.js
import "/Users/macbookpro/Documents/CurrentAllWork/bubble1/formattered/node_modules/vuetify/lib/components/VBadge/VBadge.css";
var makeVBadgeProps = propsFactory({
  bordered: Boolean,
  color: String,
  content: [Number, String],
  dot: Boolean,
  floating: Boolean,
  icon: IconValue,
  inline: Boolean,
  label: {
    type: String,
    default: "$vuetify.badge"
  },
  max: [Number, String],
  modelValue: {
    type: Boolean,
    default: true
  },
  offsetX: [Number, String],
  offsetY: [Number, String],
  textColor: String,
  ...makeComponentProps(),
  ...makeLocationProps({
    location: "top end"
  }),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeTransitionProps({
    transition: "scale-rotate-transition"
  }),
  ...makeDimensionProps()
}, "VBadge");
var VBadge = genericComponent()({
  name: "VBadge",
  inheritAttrs: false,
  props: makeVBadgeProps(),
  setup(props, ctx) {
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(() => props.color);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      t
    } = useLocale();
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(() => props.textColor);
    const {
      themeClasses
    } = useTheme();
    const {
      locationStyles
    } = useLocation(props, true, (side) => {
      const base = props.floating ? props.dot ? 2 : 4 : props.dot ? 8 : 12;
      return base + (["top", "bottom"].includes(side) ? Number(props.offsetY ?? 0) : ["left", "right"].includes(side) ? Number(props.offsetX ?? 0) : 0);
    });
    const {
      dimensionStyles
    } = useDimension(props);
    useRender(() => {
      const value = Number(props.content);
      const content = !props.max || isNaN(value) ? props.content : value <= Number(props.max) ? value : `${props.max}+`;
      const [badgeAttrs, attrs] = pickWithRest(ctx.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
      return createVNode(props.tag, mergeProps({
        "class": ["v-badge", {
          "v-badge--bordered": props.bordered,
          "v-badge--dot": props.dot,
          "v-badge--floating": props.floating,
          "v-badge--inline": props.inline
        }, props.class]
      }, attrs, {
        "style": props.style
      }), {
        default: () => {
          var _a, _b;
          return [createBaseVNode("div", {
            "class": "v-badge__wrapper"
          }, [(_b = (_a = ctx.slots).default) == null ? void 0 : _b.call(_a), createVNode(MaybeTransition, {
            "transition": props.transition
          }, {
            default: () => {
              var _a2, _b2;
              return [withDirectives(createBaseVNode("span", mergeProps({
                "class": ["v-badge__badge", themeClasses.value, backgroundColorClasses.value, roundedClasses.value, textColorClasses.value],
                "style": [backgroundColorStyles.value, textColorStyles.value, dimensionStyles.value, props.inline ? {} : locationStyles.value],
                "aria-atomic": "true",
                "aria-label": t(props.label, value),
                "aria-live": "polite",
                "role": "status"
              }, badgeAttrs), [props.dot ? void 0 : ctx.slots.badge ? (_b2 = (_a2 = ctx.slots).badge) == null ? void 0 : _b2.call(_a2) : props.icon ? createVNode(VIcon, {
                "icon": props.icon
              }, null) : content]), [[vShow, props.modelValue]])];
            }
          })])];
        }
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/composables/calendar.js
var makeCalendarProps = propsFactory({
  allowedDates: [Array, Function],
  disabled: {
    type: Boolean,
    default: null
  },
  displayValue: null,
  modelValue: Array,
  month: [Number, String],
  max: null,
  min: null,
  showAdjacentMonths: Boolean,
  year: [Number, String],
  weekdays: {
    type: Array,
    default: () => [0, 1, 2, 3, 4, 5, 6]
  },
  weeksInMonth: {
    type: String,
    default: "dynamic"
  },
  firstDayOfWeek: {
    type: [Number, String],
    default: void 0
  },
  firstDayOfYear: {
    type: [Number, String],
    default: void 0
  },
  weekdayFormat: String
}, "calendar");
function useCalendar(props) {
  const adapter = useDate();
  const model = useProxiedModel(props, "modelValue", [], (v) => wrapInArray(v).map((i) => adapter.date(i)));
  const displayValue = computed(() => {
    if (props.displayValue) return adapter.date(props.displayValue);
    if (model.value.length > 0) return adapter.date(model.value[0]);
    if (props.min) return adapter.date(props.min);
    if (Array.isArray(props.allowedDates)) return adapter.date(props.allowedDates[0]);
    return adapter.date();
  });
  const year = useProxiedModel(props, "year", void 0, (v) => {
    const value = v != null ? Number(v) : adapter.getYear(displayValue.value);
    return adapter.startOfYear(adapter.setYear(adapter.date(), value));
  }, (v) => adapter.getYear(v));
  const month = useProxiedModel(props, "month", void 0, (v) => {
    const value = v != null ? Number(v) : adapter.getMonth(displayValue.value);
    const date = adapter.setYear(adapter.startOfMonth(adapter.date()), adapter.getYear(year.value));
    return adapter.setMonth(date, value);
  }, (v) => adapter.getMonth(v));
  const weekdayLabels = computed(() => {
    const firstDayOfWeek = adapter.toJsDate(adapter.startOfWeek(adapter.date(), props.firstDayOfWeek)).getDay();
    return adapter.getWeekdays(props.firstDayOfWeek, props.weekdayFormat).filter((_, i) => props.weekdays.includes((i + firstDayOfWeek) % 7));
  });
  const weeksInMonth = computed(() => {
    const weeks = adapter.getWeekArray(month.value, props.firstDayOfWeek);
    const days = weeks.flat();
    const daysInMonth2 = 6 * 7;
    if (props.weeksInMonth === "static" && days.length < daysInMonth2) {
      const lastDay = days[days.length - 1];
      let week = [];
      for (let day = 1; day <= daysInMonth2 - days.length; day++) {
        week.push(adapter.addDays(lastDay, day));
        if (day % 7 === 0) {
          weeks.push(week);
          week = [];
        }
      }
    }
    return weeks;
  });
  function genDays(days, today) {
    return days.filter((date) => {
      return props.weekdays.includes(adapter.toJsDate(date).getDay());
    }).map((date, index) => {
      const isoDate = adapter.toISO(date);
      const isAdjacent = !adapter.isSameMonth(date, month.value);
      const isStart = adapter.isSameDay(date, adapter.startOfMonth(month.value));
      const isEnd = adapter.isSameDay(date, adapter.endOfMonth(month.value));
      const isSame = adapter.isSameDay(date, month.value);
      const weekdaysCount = props.weekdays.length;
      return {
        date,
        formatted: adapter.format(date, "keyboardDate"),
        isAdjacent,
        isDisabled: isDisabled(date),
        isEnd,
        isHidden: isAdjacent && !props.showAdjacentMonths,
        isSame,
        isSelected: model.value.some((value) => adapter.isSameDay(date, value)),
        isStart,
        isToday: adapter.isSameDay(date, today),
        isWeekEnd: index % weekdaysCount === weekdaysCount - 1,
        isWeekStart: index % weekdaysCount === 0,
        isoDate,
        localized: adapter.format(date, "dayOfMonth"),
        month: adapter.getMonth(date),
        year: adapter.getYear(date)
      };
    });
  }
  const daysInWeek = computed(() => {
    const lastDay = adapter.startOfWeek(displayValue.value, props.firstDayOfWeek);
    const week = [];
    for (let day = 0; day <= 6; day++) {
      week.push(adapter.addDays(lastDay, day));
    }
    const today = adapter.date();
    return genDays(week, today);
  });
  const daysInMonth = computed(() => {
    const days = weeksInMonth.value.flat();
    const today = adapter.date();
    return genDays(days, today);
  });
  const weekNumbers = computed(() => {
    return weeksInMonth.value.map((week) => {
      return week.length ? adapter.getWeek(week[0], props.firstDayOfWeek, props.firstDayOfYear) : null;
    });
  });
  const {
    minDate,
    maxDate
  } = useCalendarRange(props);
  function isDisabled(value) {
    if (props.disabled) return true;
    const date = adapter.date(value);
    if (minDate.value && adapter.isBefore(adapter.endOfDay(date), minDate.value)) return true;
    if (maxDate.value && adapter.isAfter(date, maxDate.value)) return true;
    if (Array.isArray(props.allowedDates) && props.allowedDates.length > 0) {
      return !props.allowedDates.some((d) => adapter.isSameDay(adapter.date(d), date));
    }
    if (typeof props.allowedDates === "function") {
      return !props.allowedDates(date);
    }
    return false;
  }
  return {
    displayValue,
    daysInMonth,
    daysInWeek,
    genDays,
    model,
    weeksInMonth,
    weekdayLabels,
    weekNumbers
  };
}
function useCalendarRange(props) {
  const adapter = useDate();
  const minDate = computed(() => {
    if (!props.min) return null;
    const date = adapter.date(props.min);
    return adapter.isValid(date) ? date : null;
  });
  const maxDate = computed(() => {
    if (!props.max) return null;
    const date = adapter.date(props.max);
    return adapter.isValid(date) ? date : null;
  });
  function clampDate(date) {
    if (minDate.value && adapter.isBefore(date, minDate.value)) {
      return minDate.value;
    }
    if (maxDate.value && adapter.isAfter(date, maxDate.value)) {
      return maxDate.value;
    }
    return date;
  }
  function isInAllowedRange(date) {
    return (!minDate.value || adapter.isAfter(date, minDate.value)) && (!maxDate.value || adapter.isBefore(date, maxDate.value));
  }
  return {
    minDate,
    maxDate,
    clampDate,
    isInAllowedRange
  };
}

// node_modules/vuetify/lib/components/VDatePicker/VDatePickerMonth.js
var makeVDatePickerMonthProps = propsFactory({
  color: String,
  hideWeekdays: Boolean,
  multiple: [Boolean, Number, String],
  showWeek: Boolean,
  transition: {
    type: String,
    default: "picker-transition"
  },
  reverseTransition: {
    type: String,
    default: "picker-reverse-transition"
  },
  events: {
    type: [Array, Function, Object],
    default: () => null
  },
  eventColor: {
    type: [Array, Function, Object, String],
    default: () => null
  },
  ...omit(makeCalendarProps(), ["displayValue"])
}, "VDatePickerMonth");
var VDatePickerMonth = genericComponent()({
  name: "VDatePickerMonth",
  props: makeVDatePickerMonthProps(),
  emits: {
    "update:modelValue": (date) => true,
    "update:month": (date) => true,
    "update:year": (date) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const daysRef = ref();
    const {
      t
    } = useLocale();
    const {
      daysInMonth,
      model,
      weekNumbers,
      weekdayLabels
    } = useCalendar(props);
    const adapter = useDate();
    const rangeStart = shallowRef();
    const rangeStop = shallowRef();
    const isReverse = shallowRef(false);
    const transition = toRef(() => {
      return !isReverse.value ? props.transition : props.reverseTransition;
    });
    if (props.multiple === "range" && model.value.length > 0) {
      rangeStart.value = model.value[0];
      if (model.value.length > 1) {
        rangeStop.value = model.value[model.value.length - 1];
      }
    }
    const atMax = computed(() => {
      const max = ["number", "string"].includes(typeof props.multiple) ? Number(props.multiple) : Infinity;
      return model.value.length >= max;
    });
    watch(daysInMonth, (val, oldVal) => {
      if (!oldVal) return;
      isReverse.value = adapter.isBefore(val[0].date, oldVal[0].date);
    });
    function onRangeClick(value) {
      const _value = adapter.startOfDay(value);
      if (model.value.length === 0) {
        rangeStart.value = void 0;
      } else if (model.value.length === 1) {
        rangeStart.value = model.value[0];
        rangeStop.value = void 0;
      }
      if (!rangeStart.value) {
        rangeStart.value = _value;
        model.value = [rangeStart.value];
      } else if (!rangeStop.value) {
        if (adapter.isSameDay(_value, rangeStart.value)) {
          rangeStart.value = void 0;
          model.value = [];
          return;
        } else if (adapter.isBefore(_value, rangeStart.value)) {
          rangeStop.value = adapter.endOfDay(rangeStart.value);
          rangeStart.value = _value;
        } else {
          rangeStop.value = adapter.endOfDay(_value);
        }
        model.value = createDateRange(adapter, rangeStart.value, rangeStop.value);
      } else {
        rangeStart.value = value;
        rangeStop.value = void 0;
        model.value = [rangeStart.value];
      }
    }
    function getDateAriaLabel(item) {
      const fullDate = adapter.format(item.date, "fullDateWithWeekday");
      const localeKey = item.isToday ? "currentDate" : "selectDate";
      return t(`$vuetify.datePicker.ariaLabel.${localeKey}`, fullDate);
    }
    function onMultipleClick(value) {
      const index = model.value.findIndex((selection) => adapter.isSameDay(selection, value));
      if (index === -1) {
        model.value = [...model.value, value];
      } else {
        const value2 = [...model.value];
        value2.splice(index, 1);
        model.value = value2;
      }
    }
    function onClick(value) {
      if (props.multiple === "range") {
        onRangeClick(value);
      } else if (props.multiple) {
        onMultipleClick(value);
      } else {
        model.value = [value];
      }
    }
    function getEventColors(date) {
      const {
        events,
        eventColor
      } = props;
      let eventData;
      let eventColors = [];
      if (Array.isArray(events)) {
        eventData = events.includes(date);
      } else if (events instanceof Function) {
        eventData = events(date) || false;
      } else if (events) {
        eventData = events[date] || false;
      } else {
        eventData = false;
      }
      if (!eventData) {
        return [];
      } else if (eventData !== true) {
        eventColors = wrapInArray(eventData);
      } else if (typeof eventColor === "string") {
        eventColors = [eventColor];
      } else if (typeof eventColor === "function") {
        eventColors = wrapInArray(eventColor(date));
      } else if (Array.isArray(eventColor)) {
        eventColors = eventColor;
      } else if (typeof eventColor === "object" && eventColor !== null) {
        eventColors = wrapInArray(eventColor[date]);
      }
      return !eventColors.length ? ["surface-variant"] : eventColors.filter(Boolean).map((color) => typeof color === "string" ? color : "surface-variant");
    }
    function genEvents(date) {
      const eventColors = getEventColors(date);
      if (!eventColors.length) return null;
      return createBaseVNode("div", {
        "class": "v-date-picker-month__events"
      }, [eventColors.map((color) => createVNode(VBadge, {
        "dot": true,
        "color": color
      }, null))]);
    }
    useRender(() => createBaseVNode("div", {
      "class": "v-date-picker-month",
      "style": {
        "--v-date-picker-days-in-week": props.weekdays.length
      }
    }, [props.showWeek && createBaseVNode("div", {
      "key": "weeks",
      "class": "v-date-picker-month__weeks"
    }, [!props.hideWeekdays && createBaseVNode("div", {
      "key": "hide-week-days",
      "class": "v-date-picker-month__day"
    }, [createTextVNode("Â ")]), weekNumbers.value.map((week) => createBaseVNode("div", {
      "class": normalizeClass(["v-date-picker-month__day", "v-date-picker-month__day--adjacent"])
    }, [week]))]), createVNode(MaybeTransition, {
      "name": transition.value
    }, {
      default: () => {
        var _a;
        return [createBaseVNode("div", {
          "ref": daysRef,
          "key": (_a = daysInMonth.value[0].date) == null ? void 0 : _a.toString(),
          "class": "v-date-picker-month__days"
        }, [!props.hideWeekdays && weekdayLabels.value.map((weekDay) => createBaseVNode("div", {
          "class": normalizeClass(["v-date-picker-month__day", "v-date-picker-month__weekday"])
        }, [weekDay])), daysInMonth.value.map((item, i) => {
          var _a2;
          const slotProps = {
            props: {
              class: "v-date-picker-month__day-btn",
              color: item.isSelected || item.isToday ? props.color : void 0,
              disabled: item.isDisabled,
              icon: true,
              ripple: false,
              variant: item.isSelected ? "flat" : item.isToday ? "outlined" : "text",
              "aria-label": getDateAriaLabel(item),
              "aria-current": item.isToday ? "date" : void 0,
              onClick: () => onClick(item.date)
            },
            item,
            i
          };
          if (atMax.value && !item.isSelected) {
            item.isDisabled = true;
          }
          return createBaseVNode("div", {
            "class": normalizeClass(["v-date-picker-month__day", {
              "v-date-picker-month__day--adjacent": item.isAdjacent,
              "v-date-picker-month__day--hide-adjacent": item.isHidden,
              "v-date-picker-month__day--selected": item.isSelected,
              "v-date-picker-month__day--week-end": item.isWeekEnd,
              "v-date-picker-month__day--week-start": item.isWeekStart
            }]),
            "data-v-date": !item.isDisabled ? item.isoDate : void 0
          }, [(props.showAdjacentMonths || !item.isAdjacent) && (((_a2 = slots.day) == null ? void 0 : _a2.call(slots, slotProps)) ?? createVNode(VBtn, slotProps.props, {
            default: () => [item.localized, genEvents(item.isoDate)]
          }))]);
        })])];
      }
    })]));
  }
});

// node_modules/vuetify/lib/components/VDatePicker/VDatePickerMonths.js
import "/Users/macbookpro/Documents/CurrentAllWork/bubble1/formattered/node_modules/vuetify/lib/components/VDatePicker/VDatePickerMonths.css";
var makeVDatePickerMonthsProps = propsFactory({
  color: String,
  height: [String, Number],
  min: null,
  max: null,
  modelValue: Number,
  year: Number,
  allowedMonths: [Array, Function]
}, "VDatePickerMonths");
var VDatePickerMonths = genericComponent()({
  name: "VDatePickerMonths",
  props: makeVDatePickerMonthsProps(),
  emits: {
    "update:modelValue": (date) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const adapter = useDate();
    const model = useProxiedModel(props, "modelValue");
    const months = computed(() => {
      let date = adapter.startOfYear(adapter.date());
      if (props.year) {
        date = adapter.setYear(date, props.year);
      }
      return createRange(12).map((i) => {
        const text = adapter.format(date, "monthShort");
        const label = adapter.format(date, "month");
        const isDisabled = !!(!isMonthAllowed(i) || props.min && adapter.isAfter(adapter.startOfMonth(adapter.date(props.min)), date) || props.max && adapter.isAfter(date, adapter.startOfMonth(adapter.date(props.max))));
        date = adapter.getNextMonth(date);
        return {
          isDisabled,
          text,
          label,
          value: i
        };
      });
    });
    watchEffect(() => {
      model.value = model.value ?? adapter.getMonth(adapter.date());
    });
    function isMonthAllowed(month) {
      if (Array.isArray(props.allowedMonths) && props.allowedMonths.length) {
        return props.allowedMonths.includes(month);
      }
      if (typeof props.allowedMonths === "function") {
        return props.allowedMonths(month);
      }
      return true;
    }
    useRender(() => createBaseVNode("div", {
      "class": "v-date-picker-months",
      "style": {
        height: convertToUnit(props.height)
      }
    }, [createBaseVNode("div", {
      "class": "v-date-picker-months__content"
    }, [months.value.map((month, i) => {
      var _a;
      const btnProps = {
        active: model.value === i,
        ariaLabel: month.label,
        color: model.value === i ? props.color : void 0,
        disabled: month.isDisabled,
        rounded: true,
        text: month.text,
        variant: model.value === month.value ? "flat" : "text",
        onClick: () => onClick(i)
      };
      function onClick(i2) {
        if (model.value === i2) {
          emit("update:modelValue", model.value);
          return;
        }
        model.value = i2;
      }
      return ((_a = slots.month) == null ? void 0 : _a.call(slots, {
        month,
        i,
        props: btnProps
      })) ?? createVNode(VBtn, mergeProps({
        "key": "month"
      }, btnProps), null);
    })])]));
    return {};
  }
});

// node_modules/vuetify/lib/components/VDatePicker/VDatePickerYears.js
import "/Users/macbookpro/Documents/CurrentAllWork/bubble1/formattered/node_modules/vuetify/lib/components/VDatePicker/VDatePickerYears.css";
var makeVDatePickerYearsProps = propsFactory({
  color: String,
  height: [String, Number],
  min: null,
  max: null,
  modelValue: Number,
  allowedYears: [Array, Function]
}, "VDatePickerYears");
var VDatePickerYears = genericComponent()({
  name: "VDatePickerYears",
  props: makeVDatePickerYearsProps(),
  directives: {
    vIntersect: intersect_default
  },
  emits: {
    "update:modelValue": (year) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const adapter = useDate();
    const model = useProxiedModel(props, "modelValue");
    const years = computed(() => {
      const year = adapter.getYear(adapter.date());
      let min = year - 100;
      let max = year + 52;
      if (props.min) {
        min = adapter.getYear(adapter.date(props.min));
      }
      if (props.max) {
        max = adapter.getYear(adapter.date(props.max));
      }
      let date = adapter.startOfYear(adapter.date());
      date = adapter.setYear(date, min);
      return createRange(max - min + 1, min).map((i) => {
        const text = adapter.format(date, "year");
        date = adapter.setYear(date, adapter.getYear(date) + 1);
        return {
          text,
          value: i,
          isDisabled: !isYearAllowed(i)
        };
      });
    });
    watchEffect(() => {
      model.value = model.value ?? adapter.getYear(adapter.date());
    });
    const yearRef = templateRef();
    function focusSelectedYear() {
      var _a, _b;
      (_a = yearRef.el) == null ? void 0 : _a.focus();
      (_b = yearRef.el) == null ? void 0 : _b.scrollIntoView({
        block: "center"
      });
    }
    function isYearAllowed(year) {
      if (Array.isArray(props.allowedYears) && props.allowedYears.length) {
        return props.allowedYears.includes(year);
      }
      if (typeof props.allowedYears === "function") {
        return props.allowedYears(year);
      }
      return true;
    }
    useRender(() => withDirectives(createBaseVNode("div", {
      "class": "v-date-picker-years",
      "style": {
        height: convertToUnit(props.height)
      }
    }, [createBaseVNode("div", {
      "class": "v-date-picker-years__content"
    }, [years.value.map((year, i) => {
      var _a;
      const btnProps = {
        ref: model.value === year.value ? yearRef : void 0,
        active: model.value === year.value,
        color: model.value === year.value ? props.color : void 0,
        rounded: true,
        text: year.text,
        disabled: year.isDisabled,
        variant: model.value === year.value ? "flat" : "text",
        onClick: () => {
          if (model.value === year.value) {
            emit("update:modelValue", model.value);
            return;
          }
          model.value = year.value;
        }
      };
      return ((_a = slots.year) == null ? void 0 : _a.call(slots, {
        year,
        i,
        props: btnProps
      })) ?? createVNode(VBtn, mergeProps({
        "key": "month"
      }, btnProps), null);
    })])]), [[intersect_default, {
      handler: focusSelectedYear
    }, null, {
      once: true
    }]]));
    return {};
  }
});

// node_modules/vuetify/lib/components/VDatePicker/VDatePicker.js
import "/Users/macbookpro/Documents/CurrentAllWork/bubble1/formattered/node_modules/vuetify/lib/components/VDatePicker/VDatePicker.css";

// node_modules/vuetify/lib/labs/VPicker/VPicker.js
import "/Users/macbookpro/Documents/CurrentAllWork/bubble1/formattered/node_modules/vuetify/lib/labs/VPicker/VPicker.css";

// node_modules/vuetify/lib/labs/VPicker/VPickerTitle.js
var VPickerTitle = createSimpleFunctional("v-picker-title");

// node_modules/vuetify/lib/labs/VPicker/VPicker.js
var makeVPickerProps = propsFactory({
  bgColor: String,
  divided: Boolean,
  landscape: Boolean,
  title: String,
  hideHeader: Boolean,
  hideTitle: Boolean,
  ...makeVSheetProps()
}, "VPicker");
var VPicker = genericComponent()({
  name: "VPicker",
  props: makeVPickerProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(() => props.color);
    useRender(() => {
      const sheetProps = VSheet.filterProps(props);
      const hasTitle = !props.hideTitle && !!(props.title || slots.title);
      return createVNode(VSheet, mergeProps(sheetProps, {
        "color": props.bgColor,
        "class": ["v-picker", {
          "v-picker--divided": props.divided,
          "v-picker--landscape": props.landscape,
          "v-picker--with-actions": !!slots.actions
        }, props.class],
        "style": props.style
      }), {
        default: () => {
          var _a;
          return [!props.hideHeader && createBaseVNode("div", {
            "key": "header",
            "class": normalizeClass(["v-picker__header-wrapper", backgroundColorClasses.value]),
            "style": normalizeStyle([backgroundColorStyles.value])
          }, [hasTitle && createVNode(VPickerTitle, {
            "key": "picker-title"
          }, {
            default: () => {
              var _a2;
              return [((_a2 = slots.title) == null ? void 0 : _a2.call(slots)) ?? props.title];
            }
          }), slots.header && createBaseVNode("div", {
            "class": "v-picker__header"
          }, [slots.header()])]), createBaseVNode("div", {
            "class": "v-picker__body"
          }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]), slots.actions && createVNode(VDefaultsProvider, {
            "defaults": {
              VBtn: {
                slim: true,
                variant: "text"
              }
            }
          }, {
            default: () => [createBaseVNode("div", {
              "class": "v-picker__actions"
            }, [slots.actions()])]
          })];
        }
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VDatePicker/VDatePicker.js
var makeVDatePickerProps = propsFactory({
  // TODO: implement in v3.5
  // calendarIcon: {
  //   type: String,
  //   default: '$calendar',
  // },
  // keyboardIcon: {
  //   type: String,
  //   default: '$edit',
  // },
  // inputMode: {
  //   type: String as PropType<'calendar' | 'keyboard'>,
  //   default: 'calendar',
  // },
  // inputText: {
  //   type: String,
  //   default: '$vuetify.datePicker.input.placeholder',
  // },
  // inputPlaceholder: {
  //   type: String,
  //   default: 'dd/mm/yyyy',
  // },
  header: {
    type: String,
    default: "$vuetify.datePicker.header"
  },
  headerColor: String,
  headerDateFormat: {
    type: String,
    default: "normalDateWithWeekday"
  },
  landscapeHeaderWidth: [Number, String],
  ...makeVDatePickerControlsProps(),
  ...makeVDatePickerMonthProps({
    weeksInMonth: "static"
  }),
  ...omit(makeVDatePickerMonthsProps(), ["modelValue"]),
  ...omit(makeVDatePickerYearsProps(), ["modelValue"]),
  ...makeVPickerProps({
    title: "$vuetify.datePicker.title"
  }),
  modelValue: null
}, "VDatePicker");
var VDatePicker = genericComponent()({
  name: "VDatePicker",
  props: makeVDatePickerProps(),
  emits: {
    "update:modelValue": (date) => true,
    "update:month": (date) => true,
    "update:year": (date) => true,
    // 'update:inputMode': (date: any) => true,
    "update:viewMode": (date) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const adapter = useDate();
    const {
      t
    } = useLocale();
    const {
      rtlClasses
    } = useRtl();
    const model = useProxiedModel(props, "modelValue", void 0, (v) => wrapInArray(v).map((i) => adapter.date(i)), (v) => props.multiple ? v : v[0]);
    const viewMode = useProxiedModel(props, "viewMode");
    const {
      minDate,
      maxDate,
      clampDate
    } = useCalendarRange(props);
    const internal = computed(() => {
      var _a;
      const today = adapter.date();
      const value = ((_a = model.value) == null ? void 0 : _a[0]) ? adapter.date(model.value[0]) : clampDate(today);
      return value && adapter.isValid(value) ? value : today;
    });
    const headerColor = toRef(() => props.headerColor ?? props.color);
    const _month = useProxiedModel(props, "month");
    const month = computed({
      get: () => Number(_month.value ?? adapter.getMonth(adapter.startOfMonth(internal.value))),
      set: (v) => _month.value = v
    });
    const _year = useProxiedModel(props, "year");
    const year = computed({
      get: () => Number(_year.value ?? adapter.getYear(adapter.startOfYear(adapter.setMonth(internal.value, month.value)))),
      set: (v) => _year.value = v
    });
    const isReversing = shallowRef(false);
    const header = computed(() => {
      if (props.multiple && model.value.length > 1) {
        return t("$vuetify.datePicker.itemsSelected", model.value.length);
      }
      const formattedDate = model.value[0] && adapter.isValid(model.value[0]) ? adapter.format(adapter.date(model.value[0]), props.headerDateFormat) : t(props.header);
      return props.landscape && formattedDate.split(" ").length === 3 ? formattedDate.replace(" ", "\n") : formattedDate;
    });
    const date = toRef(() => adapter.parseISO(`${year.value}-${month.value + 1}-01`));
    const monthYearText = toRef(() => adapter.format(date.value, "monthAndYear"));
    const monthText = toRef(() => adapter.format(date.value, "monthShort"));
    const yearText = toRef(() => adapter.format(date.value, "year"));
    const headerTransition = toRef(() => `date-picker-header${isReversing.value ? "-reverse" : ""}-transition`);
    const disabled = computed(() => {
      if (props.disabled) return true;
      const targets = [];
      if (viewMode.value !== "month") {
        targets.push(...["prev-month", "next-month", "prev-year", "next-year"]);
      } else {
        let _date = adapter.date();
        _date = adapter.startOfMonth(_date);
        _date = adapter.setMonth(_date, month.value);
        _date = adapter.setYear(_date, year.value);
        if (minDate.value) {
          const prevMonthEnd = adapter.addDays(adapter.startOfMonth(_date), -1);
          const prevYearEnd = adapter.addDays(adapter.startOfYear(_date), -1);
          adapter.isAfter(minDate.value, prevMonthEnd) && targets.push("prev-month");
          adapter.isAfter(minDate.value, prevYearEnd) && targets.push("next-year");
        }
        if (maxDate.value) {
          const nextMonthStart = adapter.addDays(adapter.endOfMonth(_date), 1);
          const nextYearStart = adapter.addDays(adapter.endOfYear(_date), 1);
          adapter.isAfter(nextMonthStart, maxDate.value) && targets.push("next-month");
          adapter.isAfter(nextYearStart, maxDate.value) && targets.push("next-year");
        }
      }
      return targets;
    });
    const allowedYears = computed(() => {
      return props.allowedYears || isYearAllowed;
    });
    const allowedMonths = computed(() => {
      return props.allowedMonths || isMonthAllowed;
    });
    function isAllowedInRange(start, end) {
      const allowedDates = props.allowedDates;
      if (typeof allowedDates !== "function") return true;
      const days = 1 + daysDiff(adapter, start, end);
      for (let i = 0; i < days; i++) {
        if (allowedDates(adapter.addDays(start, i))) return true;
      }
      return false;
    }
    function isYearAllowed(year2) {
      if (typeof props.allowedDates === "function") {
        const startOfYear = adapter.parseISO(`${year2}-01-01`);
        return isAllowedInRange(startOfYear, adapter.endOfYear(startOfYear));
      }
      if (Array.isArray(props.allowedDates) && props.allowedDates.length) {
        for (const date2 of props.allowedDates) {
          if (adapter.getYear(adapter.date(date2)) === year2) return true;
        }
        return false;
      }
      return true;
    }
    function isMonthAllowed(month2) {
      if (typeof props.allowedDates === "function") {
        const monthTwoDigits = String(month2 + 1).padStart(2, "0");
        const startOfMonth = adapter.parseISO(`${year.value}-${monthTwoDigits}-01`);
        return isAllowedInRange(startOfMonth, adapter.endOfMonth(startOfMonth));
      }
      if (Array.isArray(props.allowedDates) && props.allowedDates.length) {
        for (const date2 of props.allowedDates) {
          if (adapter.getYear(adapter.date(date2)) === year.value && adapter.getMonth(adapter.date(date2)) === month2) return true;
        }
        return false;
      }
      return true;
    }
    function onClickNextMonth() {
      if (month.value < 11) {
        month.value++;
      } else {
        year.value++;
        month.value = 0;
        onUpdateYear();
      }
      onUpdateMonth();
    }
    function onClickPrevMonth() {
      if (month.value > 0) {
        month.value--;
      } else {
        year.value--;
        month.value = 11;
        onUpdateYear();
      }
      onUpdateMonth();
    }
    function onClickNextYear() {
      year.value++;
      if (maxDate.value) {
        const monthStart = adapter.parseISO(`${year.value}-${month.value + 1}-01`);
        if (adapter.isAfter(monthStart, maxDate.value)) {
          month.value = adapter.getMonth(maxDate.value);
        }
      }
      onUpdateYear();
    }
    function onClickPrevYear() {
      year.value--;
      if (minDate.value) {
        const monthStart = adapter.endOfMonth(adapter.parseISO(`${year.value}-${month.value + 1}-01`));
        if (adapter.isAfter(minDate.value, monthStart)) {
          month.value = adapter.getMonth(minDate.value);
        }
      }
      onUpdateYear();
    }
    function onClickDate() {
      viewMode.value = "month";
    }
    function onClickMonth() {
      viewMode.value = viewMode.value === "months" ? "month" : "months";
    }
    function onClickYear() {
      viewMode.value = viewMode.value === "year" ? "month" : "year";
    }
    function onUpdateMonth() {
      if (viewMode.value === "months") onClickMonth();
    }
    function onUpdateYear() {
      if (viewMode.value === "year") onClickYear();
    }
    watch(model, (val, oldVal) => {
      const arrBefore = wrapInArray(oldVal);
      const arrAfter = wrapInArray(val);
      if (!arrAfter.length) return;
      const before = adapter.date(arrBefore[arrBefore.length - 1]);
      const after = adapter.date(arrAfter[arrAfter.length - 1]);
      if (adapter.isSameDay(before, after)) return;
      const newMonth = adapter.getMonth(after);
      const newYear = adapter.getYear(after);
      if (newMonth !== month.value) {
        month.value = newMonth;
        onUpdateMonth();
      }
      if (newYear !== year.value) {
        year.value = newYear;
        onUpdateYear();
      }
      isReversing.value = adapter.isBefore(before, after);
    });
    useRender(() => {
      const pickerProps = VPicker.filterProps(props);
      const datePickerControlsProps = omit(VDatePickerControls.filterProps(props), ["viewMode"]);
      const datePickerHeaderProps = VDatePickerHeader.filterProps(props);
      const datePickerMonthProps = VDatePickerMonth.filterProps(props);
      const datePickerMonthsProps = omit(VDatePickerMonths.filterProps(props), ["modelValue"]);
      const datePickerYearsProps = omit(VDatePickerYears.filterProps(props), ["modelValue"]);
      const headerProps = {
        color: headerColor.value,
        header: header.value,
        transition: headerTransition.value
      };
      return createVNode(VPicker, mergeProps(pickerProps, {
        "color": headerColor.value,
        "class": ["v-date-picker", `v-date-picker--${viewMode.value}`, {
          "v-date-picker--show-week": props.showWeek
        }, rtlClasses.value, props.class],
        "style": [{
          "--v-date-picker-landscape-header-width": convertToUnit(props.landscapeHeaderWidth)
        }, props.style]
      }), {
        title: () => {
          var _a;
          return ((_a = slots.title) == null ? void 0 : _a.call(slots)) ?? createBaseVNode("div", {
            "class": "v-date-picker__title"
          }, [t(props.title)]);
        },
        header: () => slots.header ? createVNode(VDefaultsProvider, {
          "defaults": {
            VDatePickerHeader: {
              ...headerProps
            }
          }
        }, {
          default: () => {
            var _a;
            return [(_a = slots.header) == null ? void 0 : _a.call(slots, headerProps)];
          }
        }) : createVNode(VDatePickerHeader, mergeProps({
          "key": "header"
        }, datePickerHeaderProps, headerProps, {
          "onClick": viewMode.value !== "month" ? onClickDate : void 0
        }), {
          prepend: slots.prepend,
          append: slots.append
        }),
        default: () => createBaseVNode(Fragment, null, [createVNode(VDatePickerControls, mergeProps(datePickerControlsProps, {
          "disabled": disabled.value,
          "viewMode": viewMode.value,
          "text": monthYearText.value,
          "monthText": monthText.value,
          "yearText": yearText.value,
          "onClick:next": onClickNextMonth,
          "onClick:prev": onClickPrevMonth,
          "onClick:nextYear": onClickNextYear,
          "onClick:prevYear": onClickPrevYear,
          "onClick:month": onClickMonth,
          "onClick:year": onClickYear
        }), {
          default: slots.controls
        }), createVNode(VFadeTransition, {
          "hideOnLeave": true
        }, {
          default: () => [viewMode.value === "months" ? createVNode(VDatePickerMonths, mergeProps({
            "key": "date-picker-months"
          }, datePickerMonthsProps, {
            "modelValue": month.value,
            "onUpdate:modelValue": [($event) => month.value = $event, onUpdateMonth],
            "min": minDate.value,
            "max": maxDate.value,
            "year": year.value,
            "allowedMonths": allowedMonths.value
          }), {
            month: slots.month
          }) : viewMode.value === "year" ? createVNode(VDatePickerYears, mergeProps({
            "key": "date-picker-years"
          }, datePickerYearsProps, {
            "modelValue": year.value,
            "onUpdate:modelValue": [($event) => year.value = $event, onUpdateYear],
            "min": minDate.value,
            "max": maxDate.value,
            "allowedYears": allowedYears.value
          }), {
            year: slots.year
          }) : createVNode(VDatePickerMonth, mergeProps({
            "key": "date-picker-month"
          }, datePickerMonthProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event,
            "month": month.value,
            "onUpdate:month": [($event) => month.value = $event, onUpdateMonth],
            "year": year.value,
            "onUpdate:year": [($event) => year.value = $event, onUpdateYear],
            "min": minDate.value,
            "max": maxDate.value
          }), {
            day: slots.day
          })]
        })]),
        actions: slots.actions
      });
    });
    return {};
  }
});

export {
  VDatePickerControls,
  VDatePickerHeader,
  useCalendarRange,
  VDatePickerMonth,
  VDatePickerMonths,
  VDatePickerYears,
  makeVDatePickerProps,
  VDatePicker
};
//# sourceMappingURL=chunk-5SZX3U57.js.map
