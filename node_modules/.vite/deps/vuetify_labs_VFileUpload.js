import {
  VSheet,
  makeVSheetProps
} from "./chunk-ZAWMUK32.js";
import {
  VListItem,
  makeVListItemProps
} from "./chunk-2RROE7HP.js";
import {
  VDivider,
  makeVDividerProps
} from "./chunk-ORXF53LD.js";
import {
  VAvatar
} from "./chunk-PABNXJSA.js";
import "./chunk-XZE5JZFS.js";
import {
  VOverlay,
  makeDelayProps
} from "./chunk-W3ZXF6L3.js";
import "./chunk-U5XS333W.js";
import "./chunk-ZKKBNG47.js";
import "./chunk-R635JELC.js";
import {
  VBtn
} from "./chunk-AKQ2NN3K.js";
import "./chunk-OTFDRXGU.js";
import "./chunk-I4WEUID3.js";
import "./chunk-P2SNVZVQ.js";
import "./chunk-GPZ4RUCS.js";
import "./chunk-KL2VGUB4.js";
import "./chunk-OIIU3TOO.js";
import "./chunk-UNHVEAQA.js";
import "./chunk-BXUC7Y7S.js";
import "./chunk-6EI4TX63.js";
import "./chunk-5EMVQ2QM.js";
import {
  makeDensityProps,
  useDensity
} from "./chunk-ALJ2XX7E.js";
import "./chunk-Y2CO7AMJ.js";
import "./chunk-NYUDTQGE.js";
import "./chunk-GSWLJLRT.js";
import {
  VDefaultsProvider
} from "./chunk-EZ6GDCL2.js";
import "./chunk-QUTCOBLL.js";
import "./chunk-NJCYCBZP.js";
import "./chunk-NQ2WIGPE.js";
import {
  VIcon
} from "./chunk-UJVLMRUY.js";
import "./chunk-VXYQOQ2E.js";
import "./chunk-WCGSDJ7Q.js";
import "./chunk-33NQPWGZ.js";
import "./chunk-N25X6P46.js";
import {
  IconValue
} from "./chunk-AGJ56T4G.js";
import {
  useLocale
} from "./chunk-6CUH4MA7.js";
import "./chunk-6TBLOJRV.js";
import "./chunk-DPOJZ66I.js";
import {
  useProxiedModel
} from "./chunk-M6IVWPQW.js";
import {
  filterInputAttrs,
  genericComponent,
  humanReadableFileSize,
  pick,
  propsFactory,
  useRender,
  wrapInArray
} from "./chunk-RHLMAGYP.js";
import {
  Fragment,
  computed,
  createBaseVNode,
  createVNode,
  mergeProps,
  ref,
  shallowRef,
  watchEffect
} from "./chunk-QCNYTOAH.js";
import "./chunk-HXA6O6EE.js";

// node_modules/vuetify/lib/labs/VFileUpload/VFileUpload.js
import "/Users/macbookpro/Documents/CurrentAllWork/formattered/node_modules/vuetify/lib/labs/VFileUpload/VFileUpload.css";

// node_modules/vuetify/lib/labs/VFileUpload/VFileUploadItem.js
var makeVFileUploadItemProps = propsFactory({
  clearable: Boolean,
  file: {
    type: Object,
    default: null
  },
  fileIcon: {
    type: String,
    // TODO: setup up a proper aliased icon
    default: "mdi-file-document"
  },
  showSize: Boolean,
  ...makeVListItemProps({
    border: true,
    rounded: true,
    lines: "two"
  })
}, "VFileUploadItem");
var VFileUploadItem = genericComponent()({
  name: "VFileUploadItem",
  props: makeVFileUploadItemProps(),
  emits: {
    "click:remove": () => true,
    click: (e) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const preview = ref();
    const base = computed(() => typeof props.showSize !== "boolean" ? props.showSize : void 0);
    function onClickRemove() {
      emit("click:remove");
    }
    watchEffect(() => {
      var _a;
      preview.value = ((_a = props.file) == null ? void 0 : _a.type.startsWith("image")) ? URL.createObjectURL(props.file) : void 0;
    });
    useRender(() => {
      var _a, _b, _c;
      const listItemProps = VListItem.filterProps(props);
      return createVNode(VListItem, mergeProps(listItemProps, {
        "class": ["v-file-upload-item", props.class],
        "title": props.title ?? ((_a = props.file) == null ? void 0 : _a.name),
        "subtitle": props.showSize ? humanReadableFileSize((_b = props.file) == null ? void 0 : _b.size, base.value) : (_c = props.file) == null ? void 0 : _c.type,
        "style": props.style
      }), {
        ...slots,
        title: slots.title ?? (() => {
          var _a2;
          return (props == null ? void 0 : props.title) ?? ((_a2 = props.file) == null ? void 0 : _a2.name);
        }),
        prepend: (slotProps) => createBaseVNode(Fragment, null, [!slots.prepend ? createVNode(VAvatar, {
          "icon": props.fileIcon,
          "image": preview.value,
          "rounded": true
        }, null) : createVNode(VDefaultsProvider, {
          "defaults": {
            VAvatar: {
              image: preview.value,
              icon: !preview.value ? props.fileIcon : void 0,
              rounded: true
            }
          }
        }, {
          default: () => {
            var _a2;
            return [((_a2 = slots.prepend) == null ? void 0 : _a2.call(slots, slotProps)) ?? createVNode(VAvatar, null, null)];
          }
        })]),
        append: (slotProps) => {
          var _a2;
          return createBaseVNode(Fragment, null, [props.clearable && createBaseVNode(Fragment, null, [!slots.clear ? createVNode(VBtn, {
            "icon": "$clear",
            "density": "comfortable",
            "variant": "text",
            "onClick": onClickRemove
          }, null) : createVNode(VDefaultsProvider, {
            "defaults": {
              VBtn: {
                icon: "$clear",
                density: "comfortable",
                variant: "text"
              }
            }
          }, {
            default: () => {
              var _a3;
              return [((_a3 = slots.clear) == null ? void 0 : _a3.call(slots, {
                ...slotProps,
                props: {
                  onClick: onClickRemove
                }
              })) ?? createVNode(VBtn, null, null)];
            }
          })]), (_a2 = slots.append) == null ? void 0 : _a2.call(slots, slotProps)]);
        }
      });
    });
  }
});

// node_modules/vuetify/lib/composables/fileDrop.js
function useFileDrop() {
  function hasFilesOrFolders(e) {
    var _a, _b;
    const entries = [...((_a = e.dataTransfer) == null ? void 0 : _a.items) ?? []].filter((x) => x.kind === "file").map((x) => x.webkitGetAsEntry()).filter(Boolean);
    return entries.length > 0 || [...((_b = e.dataTransfer) == null ? void 0 : _b.files) ?? []].length > 0;
  }
  async function handleDrop(e) {
    var _a, _b;
    const result = [];
    const entries = [...((_a = e.dataTransfer) == null ? void 0 : _a.items) ?? []].filter((x) => x.kind === "file").map((x) => x.webkitGetAsEntry()).filter(Boolean);
    if (entries.length) {
      for (const entry of entries) {
        const files = await traverseFileTree(entry, appendIfDirectory(".", entry));
        result.push(...files.map((x) => x.file));
      }
    } else {
      result.push(...[...((_b = e.dataTransfer) == null ? void 0 : _b.files) ?? []]);
    }
    return result;
  }
  return {
    handleDrop,
    hasFilesOrFolders
  };
}
function traverseFileTree(item) {
  let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return new Promise((resolve, reject) => {
    if (item.isFile) {
      const fileEntry = item;
      fileEntry.file((file) => resolve([{
        file,
        path
      }]), reject);
    } else if (item.isDirectory) {
      const directoryReader = item.createReader();
      directoryReader.readEntries(async (entries) => {
        const files = [];
        for (const entry of entries) {
          files.push(...await traverseFileTree(entry, appendIfDirectory(path, entry)));
        }
        resolve(files);
      });
    }
  });
}
function appendIfDirectory(path, item) {
  return item.isDirectory ? `${path}/${item.name}` : path;
}

// node_modules/vuetify/lib/composables/fileFilter.js
var makeFileFilterProps = propsFactory({
  filterByType: String
}, "file-accept");
function useFileFilter(props) {
  const fileFilter = computed(() => props.filterByType ? createFilter(props.filterByType) : null);
  function filterAccepted(files) {
    if (fileFilter.value) {
      const accepted = files.filter(fileFilter.value);
      return {
        accepted,
        rejected: files.filter((f) => !accepted.includes(f))
      };
    }
    return {
      accepted: files,
      rejected: []
    };
  }
  return {
    filterAccepted
  };
}
function createFilter(v) {
  const types = v.split(",").map((x) => x.trim().toLowerCase());
  const extensionsToMatch = types.filter((x) => x.startsWith("."));
  const wildcards = types.filter((x) => x.endsWith("/*"));
  const typesToMatch = types.filter((x) => !extensionsToMatch.includes(x) && !wildcards.includes(x));
  return (file) => {
    var _a, _b;
    const extension = ((_a = file.name.split(".").at(-1)) == null ? void 0 : _a.toLowerCase()) ?? "";
    const typeGroup = ((_b = file.type.split("/").at(0)) == null ? void 0 : _b.toLowerCase()) ?? "";
    return typesToMatch.includes(file.type) || extensionsToMatch.includes(`.${extension}`) || wildcards.includes(`${typeGroup}/*`);
  };
}

// node_modules/vuetify/lib/labs/VFileUpload/VFileUpload.js
var makeVFileUploadProps = propsFactory({
  browseText: {
    type: String,
    default: "$vuetify.fileUpload.browse"
  },
  dividerText: {
    type: String,
    default: "$vuetify.fileUpload.divider"
  },
  title: {
    type: String,
    default: "$vuetify.fileUpload.title"
  },
  subtitle: String,
  icon: {
    type: IconValue,
    default: "$upload"
  },
  modelValue: {
    type: [Array, Object],
    default: null,
    validator: (val) => {
      return wrapInArray(val).every((v) => v != null && typeof v === "object");
    }
  },
  clearable: Boolean,
  disabled: Boolean,
  hideBrowse: Boolean,
  multiple: Boolean,
  scrim: {
    type: [Boolean, String],
    default: true
  },
  showSize: Boolean,
  name: String,
  ...makeFileFilterProps(),
  ...makeDelayProps(),
  ...makeDensityProps(),
  ...pick(makeVDividerProps({
    length: 150
  }), ["length", "thickness", "opacity"]),
  ...makeVSheetProps()
}, "VFileUpload");
var VFileUpload = genericComponent()({
  name: "VFileUpload",
  inheritAttrs: false,
  props: makeVFileUploadProps(),
  emits: {
    "update:modelValue": (files) => true,
    rejected: (files) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit,
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const {
      densityClasses
    } = useDensity(props);
    const {
      filterAccepted
    } = useFileFilter(props);
    const model = useProxiedModel(props, "modelValue", props.modelValue, (val) => wrapInArray(val), (val) => props.multiple || Array.isArray(props.modelValue) ? val : val[0]);
    const isDragging = shallowRef(false);
    const vSheetRef = ref(null);
    const inputRef = ref(null);
    const {
      handleDrop
    } = useFileDrop();
    function onDragover(e) {
      e.preventDefault();
      e.stopImmediatePropagation();
      isDragging.value = true;
    }
    function onDragleave(e) {
      e.preventDefault();
      isDragging.value = false;
    }
    async function onDrop(e) {
      e.preventDefault();
      e.stopImmediatePropagation();
      isDragging.value = false;
      if (!inputRef.value) return;
      const allDroppedFiles = await handleDrop(e);
      selectAccepted(allDroppedFiles);
    }
    function onFileSelection(e) {
      if (!e.target || e.repack) return;
      if (!props.filterByType) {
        const target = e.target;
        model.value = [...target.files ?? []];
      } else {
        selectAccepted([...e.target.files]);
      }
    }
    function selectAccepted(files) {
      const dataTransfer = new DataTransfer();
      const {
        accepted,
        rejected
      } = filterAccepted(files);
      if (rejected.length) {
        emit("rejected", rejected);
      }
      for (const file of accepted) {
        dataTransfer.items.add(file);
      }
      inputRef.value.files = dataTransfer.files;
      model.value = [...dataTransfer.files];
      const event = new Event("change", {
        bubbles: true
      });
      event.repack = true;
      inputRef.value.dispatchEvent(event);
    }
    function onClick() {
      var _a;
      (_a = inputRef.value) == null ? void 0 : _a.click();
    }
    function onClickRemove(index) {
      const newValue = model.value.filter((_, i) => i !== index);
      model.value = newValue;
      if (newValue.length > 0 || !inputRef.value) return;
      inputRef.value.value = "";
    }
    useRender(() => {
      const hasTitle = !!(slots.title || props.title);
      const hasIcon = !!(slots.icon || props.icon);
      const hasBrowse = !!(!props.hideBrowse && (slots.browse || props.density === "default"));
      const cardProps = VSheet.filterProps(props);
      const dividerProps = VDivider.filterProps(props);
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const expectsDirectory = attrs.webkitdirectory !== void 0 && attrs.webkitdirectory !== false;
      const acceptFallback = attrs.accept ? String(attrs.accept) : void 0;
      const inputAccept = expectsDirectory ? void 0 : props.filterByType ?? acceptFallback;
      const inputNode = createBaseVNode("input", mergeProps({
        "ref": inputRef,
        "type": "file",
        "accept": inputAccept,
        "disabled": props.disabled,
        "multiple": props.multiple,
        "name": props.name,
        "onChange": onFileSelection
      }, inputAttrs), null);
      return createBaseVNode(Fragment, null, [createVNode(VSheet, mergeProps({
        "ref": vSheetRef
      }, cardProps, {
        "class": ["v-file-upload", {
          "v-file-upload--clickable": !hasBrowse,
          "v-file-upload--disabled": props.disabled,
          "v-file-upload--dragging": isDragging.value
        }, densityClasses.value, props.class],
        "style": [props.style],
        "onDragleave": onDragleave,
        "onDragover": onDragover,
        "onDrop": onDrop,
        "onClick": !hasBrowse ? onClick : void 0
      }, rootAttrs), {
        default: () => {
          var _a, _b, _c;
          return [hasIcon && createBaseVNode("div", {
            "key": "icon",
            "class": "v-file-upload-icon"
          }, [!slots.icon ? createVNode(VIcon, {
            "key": "icon-icon",
            "icon": props.icon
          }, null) : createVNode(VDefaultsProvider, {
            "key": "icon-defaults",
            "defaults": {
              VIcon: {
                icon: props.icon
              }
            }
          }, {
            default: () => [slots.icon()]
          })]), hasTitle && createBaseVNode("div", {
            "key": "title",
            "class": "v-file-upload-title"
          }, [((_a = slots.title) == null ? void 0 : _a.call(slots)) ?? t(props.title)]), props.density === "default" && createBaseVNode(Fragment, null, [createBaseVNode("div", {
            "key": "upload-divider",
            "class": "v-file-upload-divider"
          }, [((_b = slots.divider) == null ? void 0 : _b.call(slots)) ?? createVNode(VDivider, dividerProps, {
            default: () => [t(props.dividerText)]
          })]), hasBrowse && createBaseVNode(Fragment, null, [!slots.browse ? createVNode(VBtn, {
            "readonly": props.disabled,
            "size": "large",
            "text": t(props.browseText),
            "variant": "tonal",
            "onClick": onClick
          }, null) : createVNode(VDefaultsProvider, {
            "defaults": {
              VBtn: {
                readonly: props.disabled,
                size: "large",
                text: t(props.browseText),
                variant: "tonal"
              }
            }
          }, {
            default: () => [slots.browse({
              props: {
                onClick
              }
            })]
          })]), props.subtitle && createBaseVNode("div", {
            "class": "v-file-upload-subtitle"
          }, [props.subtitle])]), createVNode(VOverlay, {
            "modelValue": isDragging.value,
            "contained": true,
            "scrim": props.scrim
          }, null), ((_c = slots.input) == null ? void 0 : _c.call(slots, {
            inputNode
          })) ?? inputNode];
        }
      }), model.value.length > 0 && createBaseVNode("div", {
        "class": "v-file-upload-items"
      }, [model.value.map((file, i) => {
        const slotProps = {
          file,
          props: {
            "onClick:remove": () => onClickRemove(i)
          }
        };
        return createVNode(VDefaultsProvider, {
          "key": i,
          "defaults": {
            VFileUploadItem: {
              file,
              clearable: props.clearable,
              disabled: props.disabled,
              showSize: props.showSize
            }
          }
        }, {
          default: () => {
            var _a;
            return [((_a = slots.item) == null ? void 0 : _a.call(slots, slotProps)) ?? createVNode(VFileUploadItem, {
              "key": i,
              "onClick:remove": () => onClickRemove(i)
            }, slots)];
          }
        });
      })])]);
    });
  }
});
export {
  VFileUpload,
  VFileUploadItem
};
//# sourceMappingURL=vuetify_labs_VFileUpload.js.map
