import {
  IN_BROWSER,
  consoleWarn,
  isObject,
  propsFactory
} from "./chunk-4QS72R7V.js";
import {
  computed,
  onScopeDispose,
  toValue,
  watch
} from "./chunk-QCNYTOAH.js";

// node_modules/vuetify/lib/composables/hotkey/key-aliases.js
var keyAliasMap = {
  // Modifier aliases (from vue-use, other libraries, and current implementation)
  control: "ctrl",
  command: "cmd",
  option: "alt",
  // Arrow key aliases (common abbreviations)
  up: "arrowup",
  down: "arrowdown",
  left: "arrowleft",
  right: "arrowright",
  // Other common key aliases
  esc: "escape",
  spacebar: " ",
  space: " ",
  return: "enter",
  del: "delete",
  // Symbol aliases (existing from hotkey-parsing.ts)
  minus: "-",
  hyphen: "-"
};
function normalizeKey(key) {
  const lowerKey = key.toLowerCase();
  return keyAliasMap[lowerKey] || lowerKey;
}

// node_modules/vuetify/lib/composables/hotkey/hotkey-parsing.js
function splitKeyCombination(combination) {
  let isInternal = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const emptyResult = {
    keys: [],
    separators: []
  };
  if (!combination) {
    if (!isInternal) consoleWarn("Invalid hotkey combination: empty string provided");
    return emptyResult;
  }
  const hasInvalidLeadingSeparator = combination.length > 1 && // Starts with a single separator followed by a non-separator character (e.g. '+a', '_a')
  ["+", "/", "_"].some((v) => combination.startsWith(v)) && !["++", "//", "__"].some((v) => combination.startsWith(v));
  const hasInvalidStructure = hasInvalidLeadingSeparator || // Disallow literal + or _ keys (they require shift)
  combination.includes("++") || combination.includes("__") || combination === "+" || combination === "_" || // Ends with a separator that is not part of a doubled literal
  combination.length > 1 && (combination.endsWith("+") || combination.endsWith("_")) && combination.at(-2) !== combination.at(-1) || // Stand-alone doubled separators (dangling)
  combination === "++" || combination === "--" || combination === "__";
  if (hasInvalidStructure) {
    if (!isInternal) consoleWarn(`Invalid hotkey combination: "${combination}" has invalid structure`);
    return emptyResult;
  }
  const keys = [];
  const separators = [];
  let buffer = "";
  const flushBuffer = (separator) => {
    if (buffer) {
      separator && separators.push(separator);
      keys.push(normalizeKey(buffer));
      buffer = "";
    }
  };
  for (let i = 0; i < combination.length; i++) {
    const char = combination[i];
    const nextChar = combination[i + 1];
    if (["+", "/", "_", "-"].includes(char)) {
      if (char === nextChar) {
        flushBuffer(char);
        keys.push(char);
        i++;
      } else if (["+", "/", "_"].includes(char)) {
        flushBuffer(char);
      } else {
        buffer += char;
      }
    } else {
      buffer += char;
    }
  }
  flushBuffer();
  const hasInvalidMinus = keys.some((key) => key.length > 1 && key.includes("-") && key !== "--");
  if (hasInvalidMinus) {
    if (!isInternal) consoleWarn(`Invalid hotkey combination: "${combination}" has invalid structure`);
    return emptyResult;
  }
  if (keys.length === 0 && combination) {
    return {
      keys: [normalizeKey(combination)],
      separators
    };
  }
  return {
    keys,
    separators
  };
}
function splitKeySequence(str) {
  if (!str) {
    consoleWarn("Invalid hotkey sequence: empty string provided");
    return [];
  }
  const hasInvalidStart = str.startsWith("-") && !["---", "--+"].includes(str);
  const hasInvalidEnd = str.endsWith("-") && !str.endsWith("+-") && !str.endsWith("_-") && str !== "-" && str !== "---";
  if (hasInvalidStart || hasInvalidEnd) {
    consoleWarn(`Invalid hotkey sequence: "${str}" contains invalid combinations`);
    return [];
  }
  const result = [];
  let buffer = "";
  let i = 0;
  while (i < str.length) {
    const char = str[i];
    if (char === "-") {
      const prevChar = str[i - 1];
      const prevPrevChar = i > 1 ? str[i - 2] : void 0;
      const precededBySeparator = ["+", "_"].includes(prevChar) && !["+", "/"].includes(prevPrevChar ?? "");
      if (precededBySeparator) {
        buffer += char;
        i++;
      } else {
        if (buffer) {
          result.push(buffer);
          buffer = "";
        } else {
          result.push("-");
        }
        i++;
      }
    } else {
      buffer += char;
      i++;
    }
  }
  if (buffer) {
    result.push(buffer);
  }
  const collapsed = [];
  let minusCount = 0;
  for (const part of result) {
    if (part === "-") {
      if (minusCount % 2 === 0) collapsed.push("-");
      minusCount++;
    } else {
      minusCount = 0;
      collapsed.push(part);
    }
  }
  const areAllValid = collapsed.every((s) => splitKeyCombination(s, true).keys.length > 0);
  if (!areAllValid) {
    consoleWarn(`Invalid hotkey sequence: "${str}" contains invalid combinations`);
    return [];
  }
  return collapsed;
}

// node_modules/vuetify/lib/composables/hotkey/hotkey.js
function useHotkey(keys, callback) {
  var _a;
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!IN_BROWSER) return function() {
  };
  const {
    event = "keydown",
    inputs = false,
    preventDefault = true,
    sequenceTimeout = 1e3
  } = options;
  const isMac = ((_a = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a.includes("Macintosh")) ?? false;
  let timeout = 0;
  let keyGroups;
  let isSequence = false;
  let groupIndex = 0;
  function isInputFocused() {
    if (toValue(inputs)) return false;
    const activeElement = document.activeElement;
    return activeElement && (activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA" || activeElement.isContentEditable || activeElement.contentEditable === "true");
  }
  function resetSequence() {
    groupIndex = 0;
    clearTimeout(timeout);
  }
  function handler(e) {
    const group = keyGroups[groupIndex];
    if (!group || isInputFocused()) return;
    if (!matchesKeyGroup(e, group, isMac)) {
      if (isSequence) resetSequence();
      return;
    }
    if (toValue(preventDefault)) e.preventDefault();
    if (!isSequence) {
      callback(e);
      return;
    }
    clearTimeout(timeout);
    groupIndex++;
    if (groupIndex === keyGroups.length) {
      callback(e);
      resetSequence();
      return;
    }
    timeout = window.setTimeout(resetSequence, toValue(sequenceTimeout));
  }
  function cleanup() {
    window.removeEventListener(toValue(event), handler);
    clearTimeout(timeout);
  }
  watch(() => toValue(keys), (newKeys) => {
    cleanup();
    if (newKeys) {
      const groups = splitKeySequence(newKeys.toLowerCase());
      isSequence = groups.length > 1;
      keyGroups = groups;
      resetSequence();
      window.addEventListener(toValue(event), handler);
    }
  }, {
    immediate: true
  });
  watch(() => toValue(event), (newEvent, oldEvent) => {
    if (oldEvent && keyGroups && keyGroups.length > 0) {
      window.removeEventListener(oldEvent, handler);
      window.addEventListener(newEvent, handler);
    }
  });
  onScopeDispose(cleanup, true);
  return cleanup;
}
function matchesKeyGroup(e, group, isMac) {
  const {
    modifiers,
    actualKey
  } = parseKeyGroup(group);
  const expectCtrl = modifiers.ctrl || !isMac && (modifiers.cmd || modifiers.meta);
  const expectMeta = isMac && (modifiers.cmd || modifiers.meta);
  return e.ctrlKey === expectCtrl && e.metaKey === expectMeta && e.shiftKey === modifiers.shift && e.altKey === modifiers.alt && e.key.toLowerCase() === (actualKey == null ? void 0 : actualKey.toLowerCase());
}
function parseKeyGroup(group) {
  const MODIFIERS = ["ctrl", "shift", "alt", "meta", "cmd"];
  const {
    keys: parts
  } = splitKeyCombination(group.toLowerCase());
  if (parts.length === 0) {
    return {
      modifiers: Object.fromEntries(MODIFIERS.map((m) => [m, false])),
      actualKey: void 0
    };
  }
  const modifiers = Object.fromEntries(MODIFIERS.map((m) => [m, false]));
  let actualKey;
  for (const part of parts) {
    if (MODIFIERS.includes(part)) {
      modifiers[part] = true;
    } else {
      actualKey = part;
    }
  }
  return {
    modifiers,
    actualKey
  };
}

// node_modules/vuetify/lib/composables/mask/mask.js
var makeMaskProps = propsFactory({
  mask: [String, Object]
}, "mask");
var defaultDelimiters = /[-!$%^&*()_+|~=`{}[\]:";'<>?,./\\ ]/;
var presets = {
  "credit-card": "#### - #### - #### - ####",
  date: "##/##/####",
  "date-time": "##/##/#### ##:##",
  "iso-date": "####-##-##",
  "iso-date-time": "####-##-## ##:##",
  phone: "(###) ### - ####",
  social: "###-##-####",
  time: "##:##",
  "time-with-seconds": "##:##:##"
};
var defaultTokens = {
  "#": {
    pattern: /[0-9]/
  },
  A: {
    pattern: /[A-Z]/i,
    convert: (v) => v.toUpperCase()
  },
  a: {
    pattern: /[a-z]/i,
    convert: (v) => v.toLowerCase()
  },
  N: {
    pattern: /[0-9A-Z]/i,
    convert: (v) => v.toUpperCase()
  },
  n: {
    pattern: /[0-9a-z]/i,
    convert: (v) => v.toLowerCase()
  },
  X: {
    pattern: defaultDelimiters
  }
};
function useMask(props) {
  const mask = computed(() => {
    var _a;
    if (typeof props.mask === "string") {
      if (props.mask in presets) return presets[props.mask];
      return props.mask;
    }
    return ((_a = props.mask) == null ? void 0 : _a.mask) ?? "";
  });
  const tokens = computed(() => {
    return {
      ...defaultTokens,
      ...isObject(props.mask) ? props.mask.tokens : null
    };
  });
  function isMask(char) {
    return char in tokens.value;
  }
  function maskValidates(mask2, char) {
    if (char == null || !isMask(mask2)) return false;
    const item = tokens.value[mask2];
    if (item.pattern) return item.pattern.test(char);
    return item.test(char);
  }
  function convert(mask2, char) {
    const item = tokens.value[mask2];
    return item.convert ? item.convert(char) : char;
  }
  function maskText(text) {
    const trimmedText = text == null ? void 0 : text.trim().replace(/\s+/g, " ");
    if (trimmedText == null) return "";
    if (!mask.value.length || !trimmedText.length) return trimmedText;
    let textIndex = 0;
    let maskIndex = 0;
    let newText = "";
    while (maskIndex < mask.value.length) {
      const mchar = mask.value[maskIndex];
      const tchar = trimmedText[textIndex];
      if (mchar === "\\") {
        newText += mask.value[maskIndex + 1];
        maskIndex += 2;
        continue;
      }
      if (!isMask(mchar)) {
        newText += mchar;
        if (tchar === mchar) {
          textIndex++;
        }
      } else if (maskValidates(mchar, tchar)) {
        newText += convert(mchar, tchar);
        textIndex++;
      } else {
        break;
      }
      maskIndex++;
    }
    return newText;
  }
  function unmaskText(text) {
    if (text == null) return null;
    if (!mask.value.length || !text.length) return text;
    let textIndex = 0;
    let maskIndex = 0;
    let newText = "";
    while (true) {
      const mchar = mask.value[maskIndex];
      const tchar = text[textIndex];
      if (tchar == null) break;
      if (mchar == null) {
        newText += tchar;
        textIndex++;
        continue;
      }
      if (mchar === "\\") {
        if (tchar === mask.value[maskIndex + 1]) {
          textIndex++;
        }
        maskIndex += 2;
        continue;
      }
      if (maskValidates(mchar, tchar)) {
        newText += tchar;
        textIndex++;
        maskIndex++;
        continue;
      } else if (mchar !== tchar) {
        while (true) {
          const mchar2 = mask.value[maskIndex++];
          if (mchar2 == null || maskValidates(mchar2, tchar)) break;
        }
        continue;
      }
      textIndex++;
      maskIndex++;
    }
    return newText;
  }
  function isValid(text) {
    if (!text) return false;
    return unmaskText(text) === unmaskText(maskText(text));
  }
  function isComplete(text) {
    if (!text) return false;
    const maskedText = maskText(text);
    return maskedText.length === mask.value.length && isValid(text);
  }
  return {
    isValid,
    isComplete,
    mask: maskText,
    unmask: unmaskText
  };
}

export {
  useHotkey,
  useMask
};
//# sourceMappingURL=chunk-UJLRPQ4N.js.map
