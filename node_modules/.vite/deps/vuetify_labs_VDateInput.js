import {
  VDatePicker,
  makeVDatePickerProps,
  useCalendarRange
} from "./chunk-EU34DEHP.js";
import "./chunk-26JQ3WIK.js";
import "./chunk-N4PBO2JG.js";
import {
  VTextField,
  makeVTextFieldProps
} from "./chunk-3GCGUQT2.js";
import "./chunk-PCIHRUVL.js";
import "./chunk-WLOGHTT5.js";
import {
  createDateRange,
  useDate
} from "./chunk-2SG2QLVK.js";
import "./chunk-MVBFAXEB.js";
import {
  VBtn
} from "./chunk-UZBY7DAO.js";
import "./chunk-G5WDCYF4.js";
import "./chunk-PSOD4A44.js";
import "./chunk-RKWOLVMW.js";
import "./chunk-GSE2UIK3.js";
import "./chunk-7CULFNYJ.js";
import "./chunk-MT6OSOP4.js";
import {
  VMenu
} from "./chunk-EBEXDAKC.js";
import "./chunk-GSWLJLRT.js";
import {
  makeFocusProps
} from "./chunk-KSHYYIVO.js";
import "./chunk-BUIBLOPQ.js";
import "./chunk-WMUZRPTL.js";
import "./chunk-M2PVJVSA.js";
import "./chunk-XAWYBFQL.js";
import "./chunk-YHLQOAOR.js";
import "./chunk-FKG3RDR4.js";
import "./chunk-P6GVMNN6.js";
import "./chunk-X4TXLOIR.js";
import "./chunk-LXYYO6IX.js";
import "./chunk-BJ4LW457.js";
import "./chunk-LJHTHR7V.js";
import "./chunk-3KA5EREQ.js";
import "./chunk-YDHPBSMP.js";
import "./chunk-HTT4U7LF.js";
import "./chunk-BI2ZIEOH.js";
import "./chunk-XENYZ5JW.js";
import "./chunk-WZKVTNH2.js";
import "./chunk-VQ4DLJGF.js";
import {
  makeDisplayProps,
  useDisplay
} from "./chunk-2OMGISBO.js";
import "./chunk-4V5CYPEZ.js";
import "./chunk-UI77RI2P.js";
import {
  forwardRefs
} from "./chunk-BKGZARYA.js";
import "./chunk-NIGYBKFM.js";
import {
  useLocale
} from "./chunk-CVODYM32.js";
import "./chunk-NA4HFG2U.js";
import "./chunk-EDHH2GNY.js";
import {
  useProxiedModel
} from "./chunk-SLGGJV2F.js";
import "./chunk-XGSXMVDE.js";
import {
  consoleWarn,
  deepEqual,
  deepToRaw,
  genericComponent,
  omit,
  pick,
  propsFactory,
  useRender,
  wrapInArray
} from "./chunk-4QS72R7V.js";
import {
  Fragment,
  computed,
  createBaseVNode,
  createVNode,
  mergeProps,
  ref,
  shallowRef,
  toRef,
  watch,
  watchEffect
} from "./chunk-QCNYTOAH.js";
import "./chunk-RT7CDYDI.js";

// node_modules/vuetify/lib/components/VConfirmEdit/VConfirmEdit.js
var makeVConfirmEditProps = propsFactory({
  modelValue: null,
  color: String,
  cancelText: {
    type: String,
    default: "$vuetify.confirmEdit.cancel"
  },
  okText: {
    type: String,
    default: "$vuetify.confirmEdit.ok"
  },
  disabled: {
    type: [Boolean, Array],
    default: void 0
  },
  hideActions: Boolean
}, "VConfirmEdit");
var VConfirmEdit = genericComponent()({
  name: "VConfirmEdit",
  props: makeVConfirmEditProps(),
  emits: {
    cancel: () => true,
    save: (value) => true,
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const model = useProxiedModel(props, "modelValue");
    const internalModel = ref();
    watchEffect(() => {
      internalModel.value = structuredClone(deepToRaw(model.value));
    });
    const {
      t
    } = useLocale();
    const isPristine = computed(() => {
      return deepEqual(model.value, internalModel.value);
    });
    function isActionDisabled(action) {
      if (typeof props.disabled === "boolean") {
        return props.disabled;
      }
      if (Array.isArray(props.disabled)) {
        return props.disabled.includes(action);
      }
      return isPristine.value;
    }
    const isSaveDisabled = computed(() => isActionDisabled("save"));
    const isCancelDisabled = computed(() => isActionDisabled("cancel"));
    function save() {
      model.value = internalModel.value;
      emit("save", internalModel.value);
    }
    function cancel() {
      internalModel.value = structuredClone(deepToRaw(model.value));
      emit("cancel");
    }
    function actions(actionsProps) {
      return createBaseVNode(Fragment, null, [createVNode(VBtn, mergeProps({
        "disabled": isCancelDisabled.value,
        "variant": "text",
        "color": props.color,
        "onClick": cancel,
        "text": t(props.cancelText)
      }, actionsProps), null), createVNode(VBtn, mergeProps({
        "disabled": isSaveDisabled.value,
        "variant": "text",
        "color": props.color,
        "onClick": save,
        "text": t(props.okText)
      }, actionsProps), null)]);
    }
    let actionsUsed = false;
    useRender(() => {
      var _a;
      return createBaseVNode(Fragment, null, [(_a = slots.default) == null ? void 0 : _a.call(slots, {
        model: internalModel,
        save,
        cancel,
        isPristine: isPristine.value,
        get actions() {
          actionsUsed = true;
          return actions;
        }
      }), !props.hideActions && !actionsUsed && actions()]);
    });
    return {
      save,
      cancel,
      isPristine
    };
  }
});

// node_modules/vuetify/lib/composables/dateFormat.js
var DateFormatSpec = class _DateFormatSpec {
  constructor(order, separator) {
    this.order = order;
    this.separator = separator;
  }
  get format() {
    return this.order.split("").map((sign) => `${sign}${sign}`).join(this.separator).replace("yy", "yyyy");
  }
  static canBeParsed(v) {
    if (typeof v !== "string") return false;
    const lowercase = v.toLowerCase();
    return ["y", "m", "d"].every((sign) => lowercase.includes(sign)) && ["/", "-", "."].some((sign) => v.includes(sign));
  }
  static parse(v) {
    if (!_DateFormatSpec.canBeParsed(v)) {
      throw new Error(`[${v}] cannot be parsed into date format specification`);
    }
    const order = v.toLowerCase().split("").filter((c, i, all) => "dmy".includes(c) && all.indexOf(c) === i).join("");
    const separator = ["/", "-", "."].find((sign) => v.includes(sign));
    return new _DateFormatSpec(order, separator);
  }
};
var makeDateFormatProps = propsFactory({
  inputFormat: {
    type: String,
    validator: (v) => !v || DateFormatSpec.canBeParsed(v)
  }
}, "date-format");
function useDateFormat(props, locale) {
  const adapter = useDate();
  function inferFromLocale() {
    const localeForDateFormat = locale.value ?? "en-US";
    const formatFromLocale = Intl.DateTimeFormat(localeForDateFormat, {
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    }).format(adapter.toJsDate(adapter.parseISO("1999-12-07"))).replace(/(07)|(٠٧)|(٢٩)|(۱۶)|(০৭)/, "dd").replace(/(12)|(١٢)|(٠٨)|(۰۹)|(১২)/, "mm").replace(/(1999)|(2542)|(١٩٩٩)|(١٤٢٠)|(۱۳۷۸)|(১৯৯৯)/, "yyyy").replace(/[^ymd\-/.]/g, "").replace(/\.$/, "");
    if (!DateFormatSpec.canBeParsed(formatFromLocale)) {
      consoleWarn(`Date format inferred from locale [${localeForDateFormat}] is invalid: [${formatFromLocale}]`);
      return "mm/dd/yyyy";
    }
    return formatFromLocale;
  }
  const currentFormat = toRef(() => {
    return DateFormatSpec.canBeParsed(props.inputFormat) ? DateFormatSpec.parse(props.inputFormat) : DateFormatSpec.parse(inferFromLocale());
  });
  function parseDate(dateString) {
    function parseDateParts(text) {
      const parts = text.trim().split(currentFormat.value.separator);
      return {
        y: Number(parts[currentFormat.value.order.indexOf("y")]),
        m: Number(parts[currentFormat.value.order.indexOf("m")]),
        d: Number(parts[currentFormat.value.order.indexOf("d")])
      };
    }
    function validateDateParts(dateParts2) {
      const {
        y: year2,
        m: month2,
        d: day2
      } = dateParts2;
      if (!year2 || !month2 || !day2) return null;
      if (month2 < 1 || month2 > 12) return null;
      if (day2 < 1 || day2 > 31) return null;
      return {
        year: autoFixYear(year2),
        month: month2,
        day: day2
      };
    }
    function autoFixYear(year2) {
      const currentYear = adapter.getYear(adapter.date());
      if (year2 > 100 || currentYear % 100 >= 50) {
        return year2;
      }
      const currentCentury = ~~(currentYear / 100) * 100;
      return year2 < 50 ? currentCentury + year2 : currentCentury - 100 + year2;
    }
    const dateParts = parseDateParts(dateString);
    const validatedParts = validateDateParts(dateParts);
    if (!validatedParts) return null;
    const {
      year,
      month,
      day
    } = validatedParts;
    const pad = (v) => String(v).padStart(2, "0");
    return adapter.parseISO(`${year}-${pad(month)}-${pad(day)}`);
  }
  function isValid(text) {
    return !!parseDate(text);
  }
  function formatDate(value) {
    const parts = adapter.toISO(value).split("T")[0].split("-");
    return currentFormat.value.order.split("").map((sign) => parts["ymd".indexOf(sign)]).join(currentFormat.value.separator);
  }
  return {
    isValid,
    parseDate,
    formatDate,
    parserFormat: toRef(() => currentFormat.value.format)
  };
}

// node_modules/vuetify/lib/labs/VDateInput/VDateInput.js
var makeVDateInputProps = propsFactory({
  displayFormat: {
    type: [Function, String],
    default: void 0
  },
  location: {
    type: String,
    default: "bottom start"
  },
  menu: Boolean,
  updateOn: {
    type: Array,
    default: () => ["blur", "enter"]
  },
  ...makeDateFormatProps(),
  ...makeDisplayProps({
    mobile: null
  }),
  ...makeFocusProps(),
  ...makeVConfirmEditProps({
    hideActions: true
  }),
  ...makeVTextFieldProps({
    prependIcon: "$calendar"
  }),
  ...omit(makeVDatePickerProps({
    hideHeader: true,
    showAdjacentMonths: true
  }), ["active", "location", "rounded", "height", "minHeight", "maxHeight"])
}, "VDateInput");
var VDateInput = genericComponent()({
  name: "VDateInput",
  props: makeVDateInputProps(),
  emits: {
    save: (value) => true,
    cancel: () => true,
    "update:focused": (val) => true,
    "update:modelValue": (val) => true,
    "update:menu": (val) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const {
      t,
      current: currentLocale
    } = useLocale();
    const adapter = useDate();
    const {
      isValid,
      parseDate,
      formatDate,
      parserFormat
    } = useDateFormat(props, currentLocale);
    const {
      mobile
    } = useDisplay(props);
    const {
      clampDate,
      isInAllowedRange
    } = useCalendarRange(props);
    const emptyModelValue = () => props.multiple ? [] : null;
    const model = useProxiedModel(props, "modelValue", emptyModelValue(), (val) => Array.isArray(val) ? val.map((item) => adapter.toJsDate(item)) : val ? adapter.toJsDate(val) : val, (val) => Array.isArray(val) ? val.map((item) => adapter.date(item)) : val ? adapter.date(val) : val);
    const menu = useProxiedModel(props, "menu");
    const isEditingInput = shallowRef(false);
    const isFocused = shallowRef(props.focused);
    const vTextFieldRef = ref();
    const disabledActions = ref(["save"]);
    function format(date) {
      if (typeof props.displayFormat === "function") {
        return props.displayFormat(date);
      }
      if (props.displayFormat) {
        return adapter.format(date, props.displayFormat ?? "keyboardDate");
      }
      return formatDate(date);
    }
    const display = computed(() => {
      const value = wrapInArray(model.value);
      if (!value.length) return null;
      if (props.multiple === true) {
        return t("$vuetify.datePicker.itemsSelected", value.length);
      }
      if (props.multiple === "range") {
        const start = value[0];
        const end = value[value.length - 1];
        if (!adapter.isValid(start) || !adapter.isValid(end)) return "";
        return `${format(adapter.date(start))} - ${format(adapter.date(end))}`;
      }
      return adapter.isValid(model.value) ? format(adapter.date(model.value)) : "";
    });
    const inputmode = computed(() => {
      if (!mobile.value) return void 0;
      if (isEditingInput.value) return "text";
      return "none";
    });
    const isInteractive = computed(() => !props.disabled && !props.readonly);
    const isReadonly = computed(() => {
      if (!props.updateOn.length) return true;
      return !(mobile.value && isEditingInput.value) && props.readonly;
    });
    watch(menu, (val) => {
      if (val) return;
      isEditingInput.value = false;
      disabledActions.value = ["save"];
    });
    function onKeydown(e) {
      if (e.key !== "Enter") return;
      if (!menu.value || !isFocused.value) {
        menu.value = true;
      }
      if (props.updateOn.includes("enter") && !props.readonly) {
        onUserInput(e.target);
      }
    }
    function onClick(e) {
      e.preventDefault();
      e.stopPropagation();
      if (menu.value && mobile.value) {
        isEditingInput.value = true;
      } else {
        menu.value = true;
      }
    }
    function onCancel() {
      emit("cancel");
      menu.value = false;
      isEditingInput.value = false;
    }
    function onSave(value) {
      emit("save", value);
      menu.value = false;
    }
    function onUpdateDisplayModel(value) {
      if (value != null) return;
      model.value = emptyModelValue();
    }
    function onBlur(e) {
      if (props.updateOn.includes("blur") && !props.readonly) {
        onUserInput(e.target);
      }
      if (mobile.value && isEditingInput.value && !isFocused.value) {
        menu.value = false;
        isEditingInput.value = false;
      }
    }
    function onUserInput(_ref2) {
      let {
        value
      } = _ref2;
      if (!value.trim()) {
        model.value = emptyModelValue();
      } else if (!props.multiple) {
        if (isValid(value)) {
          model.value = clampDate(parseDate(value));
        }
      } else {
        const parts = value.trim().split(/\D+-\D+|[^\d\-/.]+/);
        if (parts.every(isValid)) {
          if (props.multiple === "range") {
            const [start, stop] = parts.map(parseDate).map(clampDate).toSorted((a, b) => adapter.isAfter(a, b) ? 1 : -1);
            model.value = createDateRange(adapter, start, stop);
          } else {
            model.value = parts.map(parseDate).filter(isInAllowedRange);
          }
        }
      }
    }
    useRender(() => {
      const confirmEditProps = VConfirmEdit.filterProps(props);
      const datePickerProps = VDatePicker.filterProps(omit(props, ["active", "bgColor", "color", "location", "rounded", "maxWidth", "minWidth", "width"]));
      const datePickerSlots = pick(slots, ["title", "header", "day", "month", "year"]);
      const textFieldProps = VTextField.filterProps(omit(props, ["placeholder"]));
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "class": props.class,
        "style": props.style,
        "modelValue": display.value,
        "inputmode": inputmode.value,
        "placeholder": props.placeholder ?? parserFormat.value,
        "readonly": isReadonly.value,
        "onKeydown": isInteractive.value ? onKeydown : void 0,
        "focused": menu.value || isFocused.value,
        "onBlur": onBlur,
        "validationValue": model.value,
        "onClick:control": isInteractive.value ? onClick : void 0,
        "onClick:prepend": isInteractive.value ? onClick : void 0,
        "onUpdate:modelValue": onUpdateDisplayModel,
        "onUpdate:focused": (event) => isFocused.value = event
      }), {
        ...slots,
        default: () => {
          var _a;
          return createBaseVNode(Fragment, null, [createVNode(VMenu, {
            "modelValue": menu.value,
            "onUpdate:modelValue": ($event) => menu.value = $event,
            "activator": "parent",
            "minWidth": "0",
            "eager": isFocused.value,
            "location": props.location,
            "closeOnContentClick": false,
            "openOnClick": false
          }, {
            default: () => [createVNode(VConfirmEdit, mergeProps(confirmEditProps, {
              "modelValue": model.value,
              "onUpdate:modelValue": ($event) => model.value = $event,
              "disabled": disabledActions.value,
              "onSave": onSave,
              "onCancel": onCancel
            }), {
              default: (_ref3) => {
                let {
                  actions,
                  model: proxyModel,
                  save,
                  cancel,
                  isPristine
                } = _ref3;
                function onUpdateModel(value) {
                  if (!props.hideActions) {
                    proxyModel.value = value;
                  } else {
                    model.value = value;
                    if (!props.multiple) {
                      menu.value = false;
                    }
                  }
                  emit("save", value);
                  disabledActions.value = [];
                }
                return createVNode(VDatePicker, mergeProps(datePickerProps, {
                  "modelValue": props.hideActions ? model.value : proxyModel.value,
                  "onUpdate:modelValue": (value) => onUpdateModel(value),
                  "onMousedown": (e) => e.preventDefault()
                }), {
                  ...datePickerSlots,
                  actions: !props.hideActions ? () => {
                    var _a2;
                    return ((_a2 = slots.actions) == null ? void 0 : _a2.call(slots, {
                      save,
                      cancel,
                      isPristine
                    })) ?? actions();
                  } : void 0
                });
              }
            })]
          }), (_a = slots.default) == null ? void 0 : _a.call(slots)]);
        }
      });
    });
    return forwardRefs({}, vTextFieldRef);
  }
});
export {
  VDateInput
};
//# sourceMappingURL=vuetify_labs_VDateInput.js.map
